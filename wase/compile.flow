import tools/dsl/dsl_runtime_common;
import tools/dsl/registry/dsl_populate;

import wase/wase2wasm;
import formats/wasm/wasm_encode;

export {
	// After type inference, we can lower to Wase
	dsl2wase(onError : (DslAst, string) -> void, d : DslAst) -> Wase;
}

dsl2wase(onError : (DslAst, string) -> void, d : DslAst) -> Wase {
	switch (d) {
		DslNode(name, args, pos): {
			b = \i -> getDslInt(args[i]) != 0;
			s = \i -> getDslString(args[i]);

			// Extract an export id
			exportid = \i, id -> {
				named = s(i);
				if (named != "") named
				else if (b(i)) id
				else ""
			};

			rec = \i -> dsl2wase(onError, args[i]);
			valtype = \i -> dsl2WasmValType(onError, args[i]);
			expr = \i -> dsl2WaseExpr(onError, args[i]);

			i = \n -> getDslInt(args[n]);
			if (name == "global") {
				WaseGlobal(s(0), exportid(1, s(0)), valtype(2), b(3), expr(4), rec(5))
			} else if (name == "function") {
				fnargs = list2array(getDslList(args[2]));
				rets = list2array(getDslList(args[3]));

				argTypes = map(fnargs, \fnarg -> {
					node = getDslNode(fnarg);
					dsl2WasmValType(onError, node.args[1]);
				});
				retTypes = map(rets, \rr -> dsl2WasmValType(onError, rr));
				fntype = WasmFuncType(argTypes, retTypes);

				fnname = s(0);

				body = dsl2WaseExpr(\node, error -> onError(node, fnname + ": " + error), args[4]);

				// Grab the arguments
				fargs = map(fnargs, \fnarg -> {
					node = getDslNode(fnarg);
					argname = getDslString(node.args[0]);
					WaseLocal(argname, dsl2WasmValType(onError, node.args[1]));
				});

				WaseFunction(fnname, exportid(1, fnname), fnname == "main", fntype, fargs, expr(4), rec(5))
			} else if (name == "import_memory") {
				minimum = i(0);
				maximum = switch (args[1]) {
					DslInt(m): m;
					default: 0;
				};
				module = s(2);
				mname = s(3);
				WaseImportMemory(module, mname, minimum, maximum, rec(4));
			} else if (name == "import_table") {
				// id reftype min max module name space				
				fname = s(0);
				tabletype = waseType(args[1]);
				minimum = i(2);
				maximum = switch (args[3]) {
					DslInt(m): m;
					default: 0;
				};
				module = s(4);
				mname = s(5);
				tt = if (tabletype == DslString("func")) WasmFuncRef()
					else if (tabletype == DslString("extern")) WasmExternRef()
					else {
						onError(d, "Only support func or extern in import table");
						WasmFuncRef()
					};
				
				WaseImportTable(fname, module, mname, tt, minimum, maximum, rec(6))

			} else if (name == "import_fun") {
				// id type module name scope
				fnname = s(0);
				fntype = waseType(args[1]);
				module = s(2);
				mname = s(3);
				WaseImportFunction(fnname, module, mname, dsl2WasmFuncType(onError, fntype), rec(4))
			} else if (name == "import_global") {
				// id type mutable module name scope
				gname = s(0);
				gtype = waseType(args[1]);
				module = s(3);
				mname = s(4);
				WaseImportGlobal(gname, module, mname, dsl2WasmValType(onError, gtype), b(2), rec(5))

			} else if (name == "memory") {
				// optexport min max
				minimum = i(1);
				maximum = switch (args[2]) {
					DslInt(m): m;
					default: 0;
				};
				WaseMemory(minimum, maximum, exportid(0, "memory"), rec(3));

			} else if (name == "data") {
				data = list2array(getDslList(args[0]));
				bytes = fold(data, [], \acc, value -> {
					switch (value) {
						DslInt(v): {
							concat(acc,
								if (v < 256) {[v]}
								else {
									// OK, we go for unsigned 32-bit
									[
										bitAnd(v, 0xff),
										bitUshr(bitAnd(v, 0xff00), 8),
										bitUshr(bitAnd(v, 0xff0000), 16),
										bitUshr(bitAnd(v, 0xff000000), 24),
									]
								}
							);
						}
						DslDouble(v): {
							// WasmI64Const(low, high): concat([0x42], wasmI64Const2bytes(i));
							// WasmF32Const(val): concat([0x43], wasmF32Const2bytes(i));
							concat3(acc,
								[0x44], 
								wasmF64Const2bytes(WasmF64Const(v))
							);
						}
						DslString(v): {
							chars = string2utf8(v);
							concat3(acc, 
								wasmEncodeU32(length(chars)),
							 	chars
							)
						}
						default: {
							onError(d, "Unsupported data " + summarizeDsl(value));
							acc
						}
					}
				});

				offset = expr(1);
				WaseData(offset, bytes, rec(2));

			} else if (name == "wase_empty") {
				WaseEmpty()

			} else {
				onError(d, "TODO: Compile " + summarizeDsl(d) + " to wase");
				WaseEmpty()
			}
		}
		default: {
			onError(d, "Expected node, not " + summarizeDsl(d));
			WaseEmpty()
		}
	}
}

dsl2WaseExpr(onError : (DslAst, string) -> void, d : DslAst) -> WaseExpr {
	WaseExpr(dsl2WaseInstruction(onError, [], d))
}

dsl2WaseInstruction(onError : (DslAst, string) -> void, acc : [WaseInstruction], d : DslAst) -> [WaseInstruction] {
	todo = \ -> {
		onError(d, "TODO: Compile " + summarizeDsl(d) + " to wase expr");
		acc
	}
	// println("Compiling " + summarizeDsl(d));
	switch (d) {
		DslBool(value): arrayPush(acc, WasmI32Const(b2i(value)));
		DslInt(value): arrayPush(acc, WasmI32Const(value));
		DslDouble(value): arrayPush(acc, WasmF64Const(value));
		DslString(value): todo(); 
		DslList(value): {
			elements = list2array(value);
			fold(elements, acc, \a, e -> dsl2WaseInstruction(onError, a, e))
		}
		DslNode(name, args, pos): {
			if (name == "int" || name == "double") {
				dsl2WaseInstruction(onError, acc, args[0])
			} else if (name == "i64") {
				uint = string2uint64(getDslString(args[0]));
				arrayPush(acc, WasmI64Const(uint))
			} else if (name == "hex32") {
				hint = parseHex(getDslString(args[0]));
				arrayPush(acc, WasmI32Const(hint))
			} else if (name == "hex64") {
				hint = hex2uint64(getDslString(args[0]));
				arrayPush(acc, WasmI64Const(hint))
			} else if (name == "hexf32") {
				hint = parseHex(getDslString(args[0]));
				arrayPush(acc, WasmF32Const(hint))
			} else if (name == "hexf64") {
				hint = hex2uint64(getDslString(args[0]));
				arrayPush(acc, WasmF64ConstHex(hint))
			} else if (name == "brace") {
				dslBrace2WaseInstruction(onError, acc, d);
			} else if (name == "block") {
				type = waseType(args[1]);
				ins = dslBrace2WaseInstruction(onError, [], d);
				arrayPush(acc, WaseBlock(dsl2WasmBlockType(onError, type), ins));
			} else if (name == "loop") {
				type = waseType(args[1]);
				ins = dslBrace2WaseInstruction(onError, [], d);
				arrayPush(acc, WaseLoop(dsl2WasmBlockType(onError, type), ins));
			} else if (name == "var") {
				arrayPush(acc, WaseGet(getDslString(args[0])))
			} else if (name == "let") {
				// (id, type, exp, body)
				type = dsl2WasmValType(onError, waseType(args[1]));
				vname = getDslString(args[0]);
				nacc = dsl2WaseInstruction(onError, acc, args[2]);
				nacc2 = arrayPush(nacc, WaseLet(vname, type));
				dsl2WaseInstruction(onError, nacc2, args[3]);

			} else if (name == "set") {
				// (id, exp)
				vname = getDslString(args[0]);
				nacc = dsl2WaseInstruction(onError, acc, args[1]);
				arrayPush(nacc, WaseSet(vname));
			} else if (name == "tee") {
				// (id, exp)
				vname = getDslString(args[0]);
				nacc = dsl2WaseInstruction(onError, acc, args[1]);
				arrayPush(nacc, WaseTee(vname));

			} else if (name == "typeannotation") {
				// We ignore the type
				dsl2WaseInstruction(onError, acc, args[0]);

			} else if (name == "call") {
				fnadded = dsl2WaseInstruction(onError, acc, args[0]);
				if (length(acc) + 1 != length(fnadded)) {
					onError(d, "Can not call " + summarizeDsl(d));
				}
				fn = lastElement(fnadded, WasmUnreachable());
				callargs = dsl2WaseInstruction(onError, acc, args[1]);
				arrayPush(callargs, WaseCall(fn));
			} else if (name == "add") {
				restype = dsl2WasmValType(onError, args[2]);
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Add())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Add())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Add())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Add())
				else {
					onError(d, "Can not add type " + toString(restype));
					nacc;
				}
			} else if (name == "sub") {
				restype = dsl2WasmValType(onError, args[2]);
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Sub())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Sub())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Sub())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Sub())
				else {
					onError(d, "Can not subtract type " + toString(restype));
					nacc;
				}
			} else if (name == "mul") {
				restype = dsl2WasmValType(onError, args[2]);
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Mul())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Mul())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Mul())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Mul())
				else {
					onError(d, "Can not mul type " + toString(restype));
					nacc;
				}
			} else if (name == "div") {
				restype = dsl2WasmValType(onError, args[2]);
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Div_s())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Div_s())
				else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Div())
				else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Div())
				else {
					onError(d, "Can not div type " + toString(restype));
					nacc;
				}
			} else if (name == "mod") {
				restype = dsl2WasmValType(onError, args[2]);
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Rem_s())
				else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Rem_s())
				else {
					onError(d, "Can not modulo type " + toString(restype));
					nacc;
				}
			} else if (name == "negate") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = dsl2WaseInstruction(onError, acc, args[0]);
				if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Neg())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Neg())
				else if (argtype == WasmI32Type()) {
					// Check if the arg is an int const
					node0 = getDslNode(args[0]);
					if (node0.name == "int") {
						val = getDslInt(node0.args[0]);
						arrayPush(acc, WasmI32Const(-val));
					} else {
						onError(d, "Negate only defined for floats, not " + summarizeDsl(args[0]));
						nacc;
					}
				} else {
					onError(d, "Negate only defined for floats, not " + summarizeDsl(args[0]));
					nacc;
				}
			} else if (name == "equal") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Eq())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Eq())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Eq())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Eq())
				else {
					onError(d, "Can not == type " + toString(argtype));
					nacc;
				}
			} else if (name == "not_equal") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Ne())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Ne())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Ne())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Ne())
				else {
					onError(d, "Can not != type " + toString(argtype));
					nacc;
				}
			} else if (name == "less_equal") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Le_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Le_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Le())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Le())
				else {
					onError(d, "Can not <= type " + toString(argtype));
					nacc;
				}
			} else if (name == "less") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Lt_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Lt_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Lt())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Lt())
				else {
					onError(d, "Can not < type " + toString(argtype));
					nacc;
				}
			} else if (name == "greater_equal") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Ge_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Ge_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Ge())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Ge())
				else {
					onError(d, "Can not >= type " + toString(argtype));
					nacc;
				}
			} else if (name == "greater") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Gt_s())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Gt_s())
				else if (argtype == WasmF32Type()) arrayPush(nacc, WasmF32Lt())
				else if (argtype == WasmF64Type()) arrayPush(nacc, WasmF64Lt())
				else {
					onError(d, "Can not > type " + toString(argtype));
					nacc;
				}
			} else if (name == "and") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32And())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64And())
				else {
					onError(d, "Can not & type " + toString(argtype));
					nacc;
				}
			} else if (name == "or") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Or())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Or())
				else {
					onError(d, "Can not | type " + toString(argtype));
					nacc;
				}
			} else if (name == "xor") {
				argtype = dsl2WasmValType(onError, waseType(args[0]));
				nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				if (argtype == WasmI32Type()) arrayPush(nacc, WasmI32Xor())
				else if (argtype == WasmI64Type()) arrayPush(nacc, WasmI64Xor())
				else {
					onError(d, "Can not ^ type " + toString(argtype));
					nacc;
				}

			} else if (name == "ifelse") {
				blocktype = dsl2WasmBlockType(onError, args[3]);
				nacc = dsl2WaseInstruction(onError, acc, args[0]);

				thens = dsl2WaseInstruction(onError, [], args[1]);
				elses = dsl2WaseInstruction(onError, [], args[2]);

				arrayPush(nacc, WaseIfElse(blocktype, thens, elses));

			} else if (name == "if") {
				blocktype = dsl2WasmBlockType(onError, args[2]);
				nacc = dsl2WaseInstruction(onError, acc, args[0]);

				thens = dsl2WaseInstruction(onError, [], args[1]);

				arrayPush(nacc, WaseIf(blocktype, thens));

			} else if (name == "return") {
				rettype = waseType(args[0]);
				argtype = dsl2WasmBlockType(onError, rettype);

				// TODO: Check that our top-level function return type matches argtype
				println("TODO: Check that the hosting function has " + summarizeDsl(rettype) + " as the return type");

				nacc = dsl2WaseInstruction(onError, acc, args[0]);
				arrayPush(nacc, WasmReturn());

			} else if (name == "is_null") {
				type = dsl2WasmValType(onError, waseType(args[0]));
				if (type == WasmFuncRef() || type == WasmExternRef()) {
				} else {
					onError(d, "is null: " + summarizeDsl(d) + " is not func or extern type");
				}

				nacc = dsl2WaseInstruction(onError, acc, args[0]);
				arrayPush(nacc, WasmRefIsNull());

			} else if (name == "wasm_op") {
				id = getDslString(args[0]);
				if (id == "hole") {
					acc;
				} else {
					pars = getDslList(args[1]);
					type = args[3];
					nacc = dsl2WaseInstruction(onError, acc, args[2]);
					fargs = getDslList(args[2]);
					argTypes = map(list2array(fargs), waseType);
					arrayPush(nacc, dslWasmOp2WaseInstruction(onError, d, id, list2array(pars), argTypes, type));
				}

			} else {
				todo();
				nacc = fold(args, acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
				nacc;
			}
		}
	}
}

dslBrace2WaseInstruction(onError : (DslAst, string) -> void, acc : [WaseInstruction], d : DslNode) -> [WaseInstruction] {
	exps = list2array(getDslList(d.args[0]));
	foldi(exps, acc, \i, acc2, e -> {
		res = dsl2WaseInstruction(onError, acc2, e);
		if (i + 1 != length(exps)) {
			type = waseType(e);
			if (isEmptyDslType(type)) {
				res;
			} else {
				switch (type) {
					DslList(l): {
						// Drop as many as the tuple has
						foldList(l, res, \acc3, ee -> {
							if (isEmptyDslType(ee)) {
								acc3
							} else {
								arrayPush(acc3, WasmDrop())	
							}
						})
					}
					default: {
						arrayPush(res, WasmDrop())
					}
				}
			}
		} else res
	})
}

dslWasmOp2WaseInstruction(onError : (DslAst, string) -> void, node : DslAst, id : string, pars : [DslAst], types : [DslAst], retType : DslAst) -> WaseInstruction {
	wtypes = map(types, \t -> dsl2WasmBlockType(onError, t));
	rtype = dsl2WasmBlockType(onError, retType);

	memargs = \defalign -> {
		if (pars != []) {
			offset = getDslInt(pars[0]);
			align = getDslInt(elementAt(pars, 1, DslInt(defalign)));
			WasmMemArg(align, offset)
		} else WasmMemArg(defalign, 0);
	}
	error = \ -> {
		onError(node, "Unknown instruction " + id + "(" + superglue(types, summarizeDsl, ", ") + ") -> " + summarizeDsl(retType) + ". Check the types");
		WasmUnreachable();
	}
	if (id == "store") {
		valType = wtypes[1];
		if (valType == WasmI32Type()) {
			WasmI32Store(memargs(2));
		} else if (valType == WasmI64Type()) {
			WasmI64Store(memargs(3));
		} else if (valType == WasmF32Type()) {
			WasmF32Store(memargs(2));
		} else if (valType == WasmF64Type()) {
			WasmF64Store(memargs(3));
		} else {
			error();
		}
	} else if (id == "load") {
		if (rtype == WasmI32Type()) {
			WasmI32Load(memargs(2));
		} else if (rtype == WasmI64Type()) {
			WasmI64Load(memargs(3));
		} else if (rtype == WasmF32Type()) {
			WasmF32Load(memargs(2));
		} else if (rtype == WasmF64Type()) {
			WasmF64Load(memargs(3));
		} else {
			error();
		}
	} else if (id == "load8_s") {
		if (rtype == WasmI32Type()) WasmI32Load8_s(memargs(0))
		else if (rtype == WasmI64Type()) WasmI64Load8_s(memargs(0))
		else error();
	} else if (id == "load8_u") {
		if (rtype == WasmI32Type()) WasmI32Load8_u(memargs(0))
		else if (rtype == WasmI64Type()) WasmI64Load8_u(memargs(0))
		else error();
	} else if (id == "load16_s") {
		if (rtype == WasmI32Type()) WasmI32Load16_s(memargs(1))
		else if (rtype == WasmI64Type()) WasmI64Load16_s(memargs(1))
		else error();
	} else if (id == "load16_u") {
		if (rtype == WasmI32Type()) WasmI32Load16_u(memargs(1))
		else if (rtype == WasmI64Type()) WasmI64Load16_u(memargs(1))
		else error();
	} else if (id == "load32_s") {
		if (rtype == WasmI64Type()) WasmI64Load32_s(memargs(2))
		else error();
	} else if (id == "load32_u") {
		if (rtype == WasmI64Type()) WasmI64Load32_u(memargs(2))
		else error();
		
	} else if (id == "store8") {
		valType = wtypes[1];
		if (valType == WasmI32Type()) WasmI32Store8(memargs(0))
		else if (valType == WasmI64Type()) WasmI64Store8(memargs(0))
		else error();
	} else if (id == "store16") {
		valType = wtypes[1];
		if (valType == WasmI32Type()) WasmI32Store16(memargs(1))
		else if (valType == WasmI64Type()) WasmI64Store16(memargs(1))
		else error();
	} else if (id == "store32") {
		valType = wtypes[1];
		if (valType == WasmI64Type()) WasmI64Store32(memargs(2))
		else error();

	} else if (id == "clz") { 
		if (rtype == WasmI32Type()) WasmI32Clz()
		else if (rtype == WasmI64Type()) WasmI64Clz()
		else error();
	} else if (id == "ctz") { 
		if (rtype == WasmI32Type()) WasmI32Ctz()
		else if (rtype == WasmI64Type()) WasmI64Ctz()
		else error();
	} else if (id == "popcnt") { 
		if (rtype == WasmI32Type()) WasmI32Popcnt()
		else if (rtype == WasmI64Type()) WasmI64Popcnt()
		else error();
	} else if (id == "shl") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmI32Type()) WasmI32Shl()
		else if (rtype == WasmI64Type()) WasmI64Shl()
		else error();
	} else if (id == "shr_s") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmI32Type()) WasmI32Shr_s()
		else if (rtype == WasmI64Type()) WasmI64Shr_s()
		else error();
	} else if (id == "shr_u") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmI32Type()) WasmI32Shr_u()
		else if (rtype == WasmI64Type()) WasmI64Shr_u()
		else error();
	} else if (id == "rotl") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmI32Type()) WasmI32Rotl()
		else if (rtype == WasmI64Type()) WasmI64Rotl()
		else error();
	} else if (id == "rotr") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmI32Type()) WasmI32Rotr()
		else if (rtype == WasmI64Type()) WasmI64Rotr()
		else error();
	} else if (id == "eqz") { 
		valType = wtypes[0];
		if (valType == WasmI32Type()) WasmI32Eqz()
		else if (valType == WasmI64Type()) WasmI64Eqz()
		else error();
	} else if (id == "div_u") {
		if (rtype == WasmI32Type()) WasmI32Div_u()
		else if (rtype == WasmI64Type()) WasmI64Div_u()
		else error();
	} else if (id == "rem_u") {
		if (rtype == WasmI32Type()) WasmI32Rem_u()
		else if (rtype == WasmI64Type()) WasmI64Rem_u()
		else error();
	} else if (id == "wrap") { WasmI32WrapI64();
	} else if (id == "trunc_s") {
		valType = wtypes[0];
		if (rtype == WasmI32Type() && valType == WasmF32Type()) WasmI32TruncF32_s()
		else if (rtype == WasmI32Type() && valType == WasmF64Type()) WasmI32TruncF64_s()
		else if (rtype == WasmI64Type() && valType == WasmF32Type()) WasmI64TruncF32_s()
		else if (rtype == WasmI64Type() && valType == WasmF64Type()) WasmI64TruncF64_s()
		else error();
	} else if (id == "trunc_u") {
		valType = wtypes[0];
		if (rtype == WasmI32Type() && valType == WasmF32Type()) WasmI32TruncF32_u()
		else if (rtype == WasmI32Type() && valType == WasmF64Type()) WasmI32TruncF64_u()
		else if (rtype == WasmI64Type() && valType == WasmF32Type()) WasmI64TruncF32_u()
		else if (rtype == WasmI64Type() && valType == WasmF64Type()) WasmI64TruncF64_u()
		else error();
	} else if (id == "trunc_sat_s") {
		valType = wtypes[0];
		if (rtype == WasmI32Type() && valType == WasmF32Type()) WasmI32Trunc_sat_f32_s()
		else if (rtype == WasmI32Type() && valType == WasmF64Type()) WasmI32Trunc_sat_f64_s()
		else if (rtype == WasmI64Type() && valType == WasmF32Type()) WasmI64Trunc_sat_f32_s()
		else if (rtype == WasmI64Type() && valType == WasmF64Type()) WasmI64Trunc_sat_f64_s()
		else error();
	} else if (id == "trunc_sat_u") {
		valType = wtypes[0];
		if (rtype == WasmI32Type() && valType == WasmF32Type()) WasmI32Trunc_sat_f32_u()
		else if (rtype == WasmI32Type() && valType == WasmF64Type()) WasmI32Trunc_sat_f64_u()
		else if (rtype == WasmI64Type() && valType == WasmF32Type()) WasmI64Trunc_sat_f32_u()
		else if (rtype == WasmI64Type() && valType == WasmF64Type()) WasmI64Trunc_sat_f64_u()
		else error();
	} else if (id == "extend_s") { WasmI64ExtendI32_s();
	} else if (id == "extend_u") { WasmI64ExtendI32_u();
	} else if (id == "extend8_s") {
		if (rtype == WasmI32Type()) WasmI32Extend8_s()
		else if (rtype == WasmI64Type()) WasmI64Extend8_s()
		else error();
	} else if (id == "extend16_s") {
		if (rtype == WasmI32Type()) WasmI32Extend16_s()
		else if (rtype == WasmI64Type()) WasmI64Extend16_s()
		else error();
	} else if (id == "convert_s") {
		valType = wtypes[0];
		if (rtype == WasmF32Type() && valType == WasmI32Type()) WasmF32ConvertI32_s()
		else if (rtype == WasmF32Type() && valType == WasmI64Type()) WasmF32ConvertI64_s()
		else if (rtype == WasmF64Type() && valType == WasmI32Type()) WasmF64ConvertI32_s()
		else if (rtype == WasmF64Type() && valType == WasmI64Type()) WasmF64ConvertI64_s()
		else error();
	} else if (id == "convert_u") {
		valType = wtypes[0];
		if (rtype == WasmF32Type() && valType == WasmI32Type()) WasmF32ConvertI32_u()
		else if (rtype == WasmF32Type() && valType == WasmI64Type()) WasmF32ConvertI64_u()
		else if (rtype == WasmF64Type() && valType == WasmI32Type()) WasmF64ConvertI32_u()
		else if (rtype == WasmF64Type() && valType == WasmI64Type()) WasmF64ConvertI64_u()
		else error();
	} else if (id == "promote") { WasmF64Promotef32();
	} else if (id == "demote") { WasmF32Demotef64();
	} else if (id == "reinterpret") {
		valType = wtypes[0];
		if (rtype == WasmF32Type() && valType == WasmI32Type()) WasmF32ReinterpretI32()
		else if (rtype == WasmI32Type() && valType == WasmF32Type()) WasmI32ReinterpretF32()
		else if (rtype == WasmF64Type() && valType == WasmI64Type()) WasmF64ReinterpretI64()
		else if (rtype == WasmI64Type() && valType == WasmF64Type()) WasmI64ReinterpretF64()
		else error();
	} else if (id == "lt_u") { 
		if (wtypes[0] != wtypes[1]) error()
		else if (wtypes[0] == WasmI32Type()) WasmI32Lt_u()
		else if (wtypes[0] == WasmI64Type()) WasmI64Lt_u()
		else error();
	} else if (id == "gt_u") { 
		if (wtypes[0] != wtypes[1]) error()
		else if (wtypes[0] == WasmI32Type()) WasmI32Gt_u()
		else if (wtypes[0] == WasmI64Type()) WasmI64Gt_u()
		else error();
	} else if (id == "le_u") { 
		if (wtypes[0] != wtypes[1]) error()
		else if (wtypes[0] == WasmI32Type()) WasmI32Le_u()
		else if (wtypes[0] == WasmI64Type()) WasmI64Le_u()
		else error();
	} else if (id == "ge_u") { 
		if (wtypes[0] != wtypes[1]) error()
		else if (wtypes[0] == WasmI32Type()) WasmI32Ge_u()
		else if (wtypes[0] == WasmI64Type()) WasmI64Ge_u()
		else error();

	} else if (id == "abs") { 
		if (rtype == WasmF32Type()) WasmF32Abs()
		else if (rtype == WasmF64Type()) WasmF64Abs()
		else error();
	} else if (id == "ceil") { 
		if (rtype == WasmF32Type()) WasmF32Ceil()
		else if (rtype == WasmF64Type()) WasmF64Ceil()
		else error();
	} else if (id == "floor") { 
		if (rtype == WasmF32Type()) WasmF32Floor()
		else if (rtype == WasmF64Type()) WasmF64Floor()
		else error();
	} else if (id == "trunc") { 
		if (rtype == WasmF32Type()) WasmF32Trunc()
		else if (rtype == WasmF64Type()) WasmF64Trunc()
		else error();
	} else if (id == "nearest") { 
		if (rtype == WasmF32Type()) WasmF32Nearest()
		else if (rtype == WasmF64Type()) WasmF64Nearest()
		else error();
	} else if (id == "sqrt") { 
		if (rtype == WasmF32Type()) WasmF32Sqrt()
		else if (rtype == WasmF64Type()) WasmF64Sqrt()
		else error();

	} else if (id == "min") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmF32Type()) WasmF32Min()
		else if (rtype == WasmF64Type()) WasmF64Min()
		else error();
	} else if (id == "max") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmF32Type()) WasmF32Max()
		else if (rtype == WasmF64Type()) WasmF64Max()
		else error();
	} else if (id == "copysign") { 
		if (!forall(wtypes, eq(rtype))) error()
		else if (rtype == WasmF32Type()) WasmF32Copysign()
		else if (rtype == WasmF64Type()) WasmF64Copysign()
		else error();

	} else if (id == "unreachable") { WasmUnreachable()
	} else if (id == "nop") { WasmNop()
	} else if (id == "drop") { WasmDrop()
	} else if (id == "break") {
		levels = if (pars == []) 0 else getDslInt(pars[0]);
		WasmBr(levels);
	} else if (id == "break_if") {
		levels = if (pars == []) 0 else getDslInt(pars[0]);
		WasmBrIf(levels);
	} else if (id == "select") {
		if (isNumericWaseType(retType)) {
			WasmSelect();
		} else {
			WasmSelectType([dsl2WasmValType(onError, retType)]);
		}
	} else if (id == "ref.null") {
		if (retType == DslString("func")) {
			WasmRefNull(WasmFuncRef());
		} else if (retType == DslString("extern")) {
			WasmRefNull(WasmExternRef());
		} else {
			error();
		}
	} else if (id == "ref.func") {
		par = getDslString(pars[0]);
		WaseRefFunc(par);

	} else if (id == "memory.size") {
		WasmMemorySize();
	} else if (id == "memory.grow") {
		WasmMemoryGrow();
	} else if (id == "memory.fill") {
		WasmMemoryFill();
	} else if (id == "memory.copy") {
		WasmMemoryCopy();

	} else if (id == "table.get") {
		tableid = getDslString(pars[0]);
		valType = wtypes[0];
		if (valType == WasmI32Type()) WaseGet(tableid)
		else error();
	} else if (id == "table.set") {
		tableid = getDslString(pars[0]);
		WaseSet(tableid)
	} else if (id == "table.grow") {
		WaseTableGrow(getDslString(pars[0]))
	} else if (id == "table.size") {
		WaseTableSize(getDslString(pars[0]))
	} else if (id == "table.copy") {
		WaseTableCopy(getDslString(pars[0]), getDslString(pars[1]))
	} else if (id == "table.fill") {
		WaseTableFill(getDslString(pars[0]))
		
	} else {
		onError(node, "Can not compile wasm op " + id);
		WasmUnreachable();
	}
}

waseType(d : DslAst) -> DslAst {
	switch (d) {
		DslNode(__, args, __): {
			lastElement(args, d);
		}
		DslInt(tv): {
			println("TODO: Why do we have a tyvar, and not a resolved type?");
			d;
		}
		default: d;
	}
}

dsl2WasmValType(onError : (DslAst, string) -> void, d : DslAst) -> WasmValType {
	error = \ -> {
		onError(d, "Error: Can not compile " + summarizeDsl(d) + " to wasm val type");
		WasmI32Type();
	}
	switch (d) {
		DslString(type): {
			if (type == "i32") WasmI32Type()
			else if (type == "i64") WasmI64Type()
			else if (type == "f32") WasmF32Type()
			else if (type == "f64") WasmF64Type()
			else if (type == "v128") WasmVecType()
			else if (type == "func") WasmFuncRef()
			else if (type == "extern") WasmExternRef()
			else {
				error();
			}
		}
		DslNode(name, args, __): {
			if (name == "type") {
				dsl2WasmValType(onError, args[1])
			} else if (name == "") {
				onError(d, "Could not resolve type. Add type annotation");
				WasmI32Type();
			} else {
				error();
			}
		}
		DslList(v): {
			error();
		}
		default: error();
	}
}

dsl2WasmFuncType(onError : (DslAst, string) -> void, d : DslAst) -> WasmFuncType {
	node : DslNode = getDslNode(d);
	argTypes = map(list2array(getDslList(node.args[0])), \tt -> dsl2WasmValType(onError, tt));
	retTypes = map(list2array(getDslList(node.args[1])), \tt -> dsl2WasmValType(onError, tt));
	WasmFuncType(argTypes, retTypes);
}

isEmptyDslType(d : DslAst) -> bool {
	switch (d) {
		DslList(l): isEmptyList(l) || {
			forall(list2array(l), isEmptyDslType)
		}
		DslNode(n, __, __): n == "";
		default: false;
	}
}

dsl2WasmBlockType(onError : (DslAst, string) -> void, d : DslAst) -> WasmBlockType {
	error = \ -> {
		onError(d, "Error: Could not compile " + summarizeDsl(d) + " to wasm block type");
		WasmI32Type();
	}
	switch (d) {
		DslString(type): {
			if (type == "i32") WasmI32Type()
			else if (type == "i64") WasmI64Type()
			else if (type == "f32") WasmF32Type()
			else if (type == "f64") WasmF64Type()
			else if (type == "v128") WasmVecType()
			else if (type == "func") WasmFuncRef()
			else if (type == "extern") WasmExternRef()
			else {
				error();
			}
		}
		DslList(l): {
			if (isEmptyList(l)) {
				WasmEmptyType()
			} else error();
		}
		DslNode(name, __, __): {
			if (name == "") {
				// onError(d, "Could not resolve type. Add type annotation");
				WasmEmptyType();
			} else {
				error();
			}			
		}
		default: error();
	}
}

/*
		type = "(" ws types ")" ws "->" ws type $"fntype_2"
			| id "<" ws types ">" ws $"partype_2"

*/


isNumericWaseType(d : DslAst) -> bool {
	contains([DslString("i32"), DslString("i64"), DslString("f32"), DslString("f64")], d)
}
