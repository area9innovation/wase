import wase/wase_types;
import wase/wase_ast;
import wase/pretty_wase_ast;

import formats/wasm/wasm_encode;

export {
	//waseAst2wase(w : WaseAst) -> WaseAll;
	weDecl2wase(onError : (WaseAst, string) -> void, decl : WeDecl) -> Wase;
}

weDecl2wase(onError : (WaseAst, string) -> void, decl : WeDecl) -> Wase {
	switch (decl) {
		WeData(id, size, data, offset, next): {
			bytes = fold(data, [], \acc, value -> {
				switch (value) {
					WeInt(v): {
						concat(acc,
							if (v < 256) {[v]}
							else {
								// OK, we go for unsigned 32-bit
								[
									bitAnd(v, 0xff),
									bitUshr(bitAnd(v, 0xff00), 8),
									bitUshr(bitAnd(v, 0xff0000), 16),
									bitUshr(bitAnd(v, 0xff000000), 24),
								]
							}
						);
					}
					WeDouble(v): {
						// WasmI64Const(low, high): concat([0x42], wasmI64Const2bytes(i));
						// WasmF32Const(val): concat([0x43], wasmF32Const2bytes(i));
						concat3(acc,
							[0x44], 
							wasmF64Const2bytes(WasmF64Const(v))
						);
					}
					WeString(v): {
						chars = string2utf8(v);
						concat3(acc, 
							wasmEncodeU32(length(chars)),
							chars
						)
					}
				}
			});
			WaseData(id, size, weExp2waseExpr(onError, offset), bytes, weDecl2wase(onError, next));
		}
		WeFunction(id, _export, args, rettypes, expr, next): {
			WaseFunction(id, _export, id == "main", 
				WasmFuncType(
					map(args, \arg -> weType2WaseType(onError, arg.type)),
					map(rettypes, \tp -> weType2WaseType(onError, tp))
				), 
				map(args, \arg -> WaseLocal(arg.id, weType2WaseType(onError, arg.type))),
				weExp2waseExpr(onError, expr), 
				weDecl2wase(onError, next)
			);
		}
		WeGlobal(id, _export, type, is_mutable, init, next): {
			WaseGlobal(id, _export, 
				weType2WaseType(onError, type), 
				is_mutable == 1, 
				weExp2waseExpr(onError, init), 
				weDecl2wase(onError, next)
			);
		}
		WeImportFun(id, fntype, module, name, next): {
			WaseImportFunction(id, module, name, 
				weFnType2WasmFuncType(onError, fntype), 
				weDecl2wase(onError, next)
			); 
		}
		WeImportGlobal(id, type, is_mutable, module, name, next): {
			WaseImportGlobal(id, module, name, 
				weType2WaseType(onError, type), 
				is_mutable == 1, 
				weDecl2wase(onError, next)
			);
		}
		WeImportMemory(minPages, maxPages, module, name, next): {
			WaseImportMemory(module, name, minPages, maxPages, 
				weDecl2wase(onError, next)
			);
		}
		WeImportTable(id, rt, minPages, maxPages, module, name, next): {
			reftype = if (rt.s == "func") WasmFuncRef()
			else if (rt.s == "extern") WasmExternRef()
			else {
				onError(decl, "Only support func or extern in import table");
				WasmFuncRef();
			};
			WaseImportTable(id, module, name, reftype, minPages, maxPages, 
				weDecl2wase(onError, next)
			);
		}
		WeMemory(_export, min_pages, max_pages, next): {
			WaseMemory(min_pages, max_pages, _export, weDecl2wase(onError, next));
		}
		WeWaseInclude(inc, next): {
			// TODO: implement include in Wase
			WaseEmpty();
		}
		WeWaseEmpty(): WaseEmpty();
	}
}

weExp2waseExpr(onError : (WaseAst, string) -> void, e : WeExp) -> WaseExpr {
	WaseExpr(weExp2waseInstruction(onError, e, []));
}

weExp2waseInstruction(onError : (WaseAst, string) -> void, expr : WeExp, acc : [WaseInstruction]) -> [WaseInstruction] {
/*	switch (expr) {
		WeAdd(e1, e2): {
			restype = dsl2WasmValType(onError, args[2]);
			nacc = fold(subrange(args, 0, 2), acc, \a, aa -> dsl2WaseInstruction(onError, a, aa));
			if (restype == WasmI32Type()) arrayPush(nacc, WasmI32Add())
			else if (restype == WasmI64Type()) arrayPush(nacc, WasmI64Add())
			else if (restype == WasmF32Type()) arrayPush(nacc, WasmF32Add())
			else if (restype == WasmF64Type()) arrayPush(nacc, WasmF64Add())
			else {
				onError(d, "Can not add type " + toString(restype));
				nacc;
			}
		}
		WeAnd(e1, e2):
		WeArray(es):
		WeDouble(d):
		WeHex32(s):
		WeHex64(s)
		WeHexf32(s)
		WeHexf64,(s)
		WeI64(s)
		WeIf(c, pos):
		WeIfelse(c, pos, neg): 
		WeInt(i):
		WeSet(v, e):
		WeTee(v, e):
		WeVar(v):
		WeBlock(es):
		WeLoop(es):
		WeReturn(e): 
		WeZreturn():
		WeBrace(es):
		WeCall(fn, args):
		WeDiv(e1, e2):
		WeEqual(e1, e2):
		WeGreater(e1, e2):
		WeGreaterEqual(e1, e2):
		WeIsNull(e):
		WeLess(e1, e2):
		WeLessEqual(e1, e2):
		WeLet(v, e):
		WeLettuple(v, i, types, e, next): 
		WeMod(e1, e2):
		WeMul(e1, e2):
		WeNegate(e):
		WeNotEqual(e1, e2):
		WeOr(e1, e2):
		WeSub(e1, e2):
		WeTypeAnnotation(e, types):
		WeWasmOp(op, wargs, es):
		WeXor(e1, e2);
	}*/
	[]
}

//  $("i32" | "i64" | "f32" | "f64" | "v128" | "func" | "extern" | "auto") $"type_1" ws;

weType2WaseType(onError : (WaseAst, string) -> void, t : WeType) -> WasmValType {
	if (t.s == "i32") WasmI32Type() else
	if (t.s == "i64") WasmI64Type() else
	if (t.s == "f32") WasmF32Type() else
	if (t.s == "f64") WasmF64Type() else
	if (t.s == "v128") WasmVecType() else
	if (t.s == "func") WasmFuncRef() else
	if (t.s == "extern") WasmExternRef() else {
		onError(t, "Error: Can not compile '" + prettyWaseAst(t) + "' to wasm val type");
		WasmI32Type();
	}
}

weFnType2WasmFuncType(onError : (WaseAst, string) -> void, fntype : WeFnType) -> WasmFuncType {
	WasmFuncType(
		map(fntype.types, \t -> weType2WaseType(onError, t)),
		map(fntype.typeList, \t -> weType2WaseType(onError, t)),
	);
}