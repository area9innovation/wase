import tools/dsl/dsl_ast;
import tools/dsl/dsl_util;
import ds/tree;
import fs/filesystem;
import wase/parse;

export {
	// Find this file, using the include path
	resolveWaseFile(includes : [string], file : string) -> string;

	// Process all wase includes
	processWaseIncludes(includes : [string], included : ref Set<string>, suffix : string, d : DslAst) -> DslAst;
}

resolveWaseFile(includes : [string], file : string) -> string {
	if (fileExists(file)) resolveRelativePath(file)
	else if (includes == []) ""
	else {
		path = pathCombine(includes[0], file);
		if (fileExists(path)) resolveRelativePath(path)
		else {
			resolveWaseFile(tail(includes), file);
		}
	}
}

processWaseIncludes(includes : [string], included : ref Set<string>, suffix : string, d : DslAst) -> DslAst {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(value): DslList(mapList(value, \vv -> processWaseIncludes(includes, included, suffix, vv)));
		DslNode(name, args, pos): {
			if (name == "wase_include") {
				file = getDslString(args[0]);
				filename = resolveWaseFile(includes, changeFileExt(file, suffix));
				if (containsSet(^included, filename)) {
					// Already included. No need to do it again
					args[1];
				} else if (fileExists(filename)) {
					included := insertSet(^included, filename);
					code = getFileContent(filename);
					program = parseWase(file, code);
					if (isUrlParameterTrue("verbose")) {
						println("  Included '" + file + "' as " + resolveRelativePath(filename));
					}
					processWaseIncludes(includes, included, suffix, replaceWaseEmpty(program, args[1]));
				} else {
					println("ERROR: Could not include " + file);
					args[1];
				}
			} else {
				DslNode(name, map(args, \a -> processWaseIncludes(includes, included, suffix, a)), pos);
			}
		}
	}
}

replaceWaseEmpty(d : DslAst, replacement : DslAst) {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(value): DslList(mapList(value, \vv -> replaceWaseEmpty(vv, replacement)));
		DslNode(name, args, pos): {
			if (name == "wase_empty") {
				replacement;
			} else {
				DslNode(name, map(args, \a -> replaceWaseEmpty(a, replacement)), pos);
			}
		}
	}
}
