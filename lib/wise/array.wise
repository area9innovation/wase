include lib/wise/runtime;


// typeSize in bytes
initArray(length : i32, typeSize : i32) -> i32 {
	if (length >= 0 && typeSize > 0) {
		adr : i32 = allocateArrayMemory(arrayOffset + length * typeSize); // data + 2 service fields
		
		store<>(adr, 1); // counter
		store<>(adr + 4, length);

		adr + arrayOffset;
	} else {
		// error
		0
	}
}

getArrayLength(arrayAdr : i32) -> i32 {
	counter : i32 = getArrayCounter(arrayAdr);
	if (counter > 0) {
		getArrayItemsCount(arrayAdr);
	} else {
		0;
	}
}

// dup fields
// increment counter
// error ?
dupArray(arrayAdr : i32) -> () {
	counter : i32 = getArrayCounter(arrayAdr);
	if (counter > 0) {
		setArrayCounter(arrayAdr, counter + 1); // counter
	} else {
		// error. array is dead
	}
}

// drop fields
// decrement counter
dropArray(arrayAdr : i32) -> () {
	counter : i32 = getArrayCounter(arrayAdr) - 1;
	setArrayCounter(arrayAdr, counter);
	// dropFields here
	if (counter < 1) {
		freeArray(arrayAdr);
	} else {
		// ok
	}
}

concat2Arrays(src1 : i32, src2 : i32, typeSize : i32) -> i32 {
	len1 : i32 = getArrayLength(src1);
	len2 : i32 = getArrayLength(src2);

	dst : i32 = resizeArray(src1, typeSize, len1 + len2);

	if (len2 > 0) {
		memory.copy<>(dst + len1 * typeSize, src2, len2 * typeSize);
	};

	dst;
}

// make a copy
resizeArray(src : i32, typeSize : i32, newLen : i32) -> i32 {
	dst : i32 = initArray(newLen, typeSize);
	len : i32 = getArrayLength(src);
	minLen : i32 = if (newLen > len) len else newLen;
	if (minLen > 0) {
		memory.copy<>(dst, src, newLen * typeSize);
	};
	dst;
}

subrangeArray(arrayAdr : i32, index : i32, length : i32, typeSize : i32) -> i32 {
	newLen : i32 = if (index < 0 || length < 1) {
		0;
	} else {
		len : i32 = getArrayLength(arrayAdr);
		if (index >= len) {
			0;
		} else {
			lenToEnd : i32 = len - index;
			if (length > lenToEnd) lenToEnd else length;
		}
	};

	dst : i32 = initArray(newLen, typeSize);

	if (newLen > 0) {
		memory.copy<>(dst, arrayAdr + index * typeSize, newLen * typeSize);
	};
	dst;
}

//_____________________________________________________

// first free cell
ARRAY_HEAP_POINTER : i32 = 4096;
// offset before data starts
arrayOffset : i32 = 8;
//arrayOffset : i32 = 2 * 4; // error: invalid initializer: instruction not valid in initializer expression: i32.mul

getArrayCounter(arrayAdr : i32) -> i32 {
	load<>(arrayAdr - arrayOffset);
}

getArrayItemsCount(arrayAdr : i32) -> i32 {
	load<>(arrayAdr - 4);
}

setArrayCounter(arrayAdr : i32, value : i32) -> () {
	store<>(arrayAdr - arrayOffset, value);
}

// TODO: find the first free cell
// Heap address is hidden
// size  - size in bytes
// result - address of the block
allocateArrayMemory(size : i32) -> i32 {
	freeCell : i32 = load<>(ARRAY_HEAP_POINTER);
	store<>(ARRAY_HEAP_POINTER, freeCell + size); // move the ptr to the next free cell
	freeCell;
}

freeArrayMemory(address : i32) -> () {
	// mark the memory region as free
	// free cells ?
}

// common free ?
freeArray(arrayAdr : i32) -> () {
	setArrayCounter(arrayAdr, 0); // reset counter
	freeArrayMemory(arrayAdr);
}

//_____________________________________________________

// magic ?
initMemory() -> () {
	store<>(ARRAY_HEAP_POINTER, ARRAY_HEAP_POINTER + arrayOffset);
}