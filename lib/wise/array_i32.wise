// array of i32 (numbers)
// values aren't pointers, so they don't have own counters
// ~= array of constants

// array structure (bytes : data)
// 0-3  : counter
// 4-7  : length (items count)
// 8+ : values

include lib/wise/array;

// ---------------------------------------------------------------------------
// PUBLIC

// result is an address
createArrayI32(length : i32) -> i32 {
	initArray(length, i32NumSize);
	// TODO : fill with 0 ?
	// memory.fill<>(adr, 0, length * i32NumSize);
}

setValueArrayI32(arrayAdr : i32, index : i32, value : i32) -> () {
	// dup(value)
	setValueArrayI32E(arrayAdr, index, value);
	// drop(arrayAdr);
	{}
}

getArrayLengthI32(arrayAdr : i32) -> i32 {
	len : i32 = getArrayLength(arrayAdr);
	// drop(arrayAdr);
	len;
}

// dup is in the flow (dup(getValueArrayI32()))
// if it is the last dup, getValueArrayI32()
// result : value or 0 if error
getValueArrayI32(arrayAdr : i32, index : i32) -> i32 {
	// dupField(arrayAdr, index)
	res : (i32, i32) = getValueArrayI32E(arrayAdr, index);
	// dropArray(arrayAdr);
	errCode : i32 = res.0;
	// if (res.0 == 0) { // error!
	if (errCode == 0) {
		// dup(res) ??
		res.1;
	} else {
		0; // max/min int ?
	};
}

// don't do deep copy
// We can't reuse memory
// in flow : 
// concat(dup(adr1), dup(adr2)) or concat(adr1, adr2)
concatArraysI32(adr1 : i32, adr2 : i32) -> i32 {
	// dupFields(adr1);
	// dupFields(adr2);
	adr : i32 = concat2Arrays(adr1, adr2, i32NumSize);
	
	// dropArray(adr1);
	// dropArray(adr2);

	adr;
}

// We can't reuse memory
// don't do deep copy
arrayPushI32(arrayAdr : i32, value : i32) -> i32 {
	// dupFields(arrayAdr);
	len : i32 = getArrayLength(arrayAdr);
	res : i32 = resizeArray(arrayAdr, i32NumSize, len + 1);
	// dropArray(arrayAdr);
	// drop(value)
	setArrayItemI32(res, len, value);
	res;
}

// don't do deep copy
subrangeArrayI32(arrayAdr : i32, index : i32, length : i32) -> i32 {
	// dupFields(arrayAdr); in range
	arr : i32 = subrangeArray(arrayAdr, index, length, i32NumSize);
	// dup(arr)
	// dropArray(arrayAdr);
	arr;
}

// don't do deep copy
replaceArrayI32(arrayAdr : i32, index : i32, value : i32) -> i32 {
	// dup(value) ?
	len : i32 = getArrayLength(arrayAdr);
	newArr : i32 = if (index < 0) {
		// copy arr
		subrangeArray(arrayAdr, 0, len, i32NumSize);
	} else {
		// reuse
		//if (getArrayCounter(arrayAdr) == 1) {
		//	if (index >= len) {
		//		// dup(arrayAdr);
		//		// dup(value)
		//		arrayPushI32(arrayAdr, value);
		//	} else {
				// replace
		//		setArrayItemI32(arrayAdr, index, value);
		//		arrayAdr;
		//	}
		//} else {
			newLen : i32 = if (index >= len) len + 1 else len;
			arr : i32 = resizeArray(arrayAdr, i32NumSize, newLen);
			setArrayItemI32(arr, if (index >= len) len else index, value);
			arr;
		//}
	};
	// dropArray(arrayAdr);
	// drop(value)
	newArr;
}


compareArraysI32(adr1 : i32, adr2 : i32) -> i32 {
	res : i32 = compareArraysI32E(adr1, adr2);
	if (res < -1) -1 else res;
}

// -1 - a1<a2, 0 - a1==a1, 1 - a1>a2, -2(+) - wrong index
compareArraysI32E(adr1 : i32, adr2 : i32) -> i32 {
	len1 : i32 = getArrayLength(adr1);
	len2 : i32 = getArrayLength(adr2);
	
	if (len1 == 0 || len2 == 0) {
		return (if (len1 == 0 && len2 == 0) 0 else if (len1 == 0) -1 else 1);
	};

	minLen : i32 = if (len1 < len2) len1 else len2;
	var i = 0;
	while (i < minLen) {
		v1 : (i32, i32) = getValueArrayI32E(adr1, i);
		v2 : (i32, i32) = getValueArrayI32E(adr2, i);
		err1 : i32 = v1.0;
		err2 : i32 = v2.0;
		val1 : i32 = v1.1;
		val2 : i32 = v2.1;
		if (err1 == 0 && err2 == 0) {
			if (val1 != val2) return (if (val1 < val2) -1 else 1);
		} else {
			return -3;
		};
		i := i + 1;
	};
	return (if (len1 == len2) 0 else if (len1 < len2) -1 else 1);
}

// iter // fn as an arg!
// map? // perceus

// ---------------------------------------------------------------------------
// PRIVATE

i32NumSize : i32 = 4;

// result : (error_code, value)
// error_code : 0 - ok, 1 - wrong index, 2 - dead array
getValueArrayI32E(arrayAdr : i32, index : i32) -> (i32, i32) {
	if (index >= 0) {
		counter : i32 = getArrayCounter(arrayAdr);
		if (counter > 0) {
			len : i32 = getArrayLength(arrayAdr);
			if (index < len) {
				element : i32 = load<>(arrayAdr + i32NumSize * index);
				// (0, load<>(...)) // error
				(0, element);
			} else {
				(1, 0);
			}
		} else {
			(2, 0);
		}
	} else {
		(1, 0);
	}
}

// result = error_code :
// 0 - ok, 1,3 - wrong index, 2 - deleted object
setValueArrayI32E(arrayAdr : i32, index : i32, value : i32) -> i32 {
	if (index >= 0) {
		counter : i32 = getArrayCounter(arrayAdr);
		if (counter > 0) {
			len : i32 = getArrayLength(arrayAdr);
			if (index < len) {
				setArrayItemI32(arrayAdr, index, value);
				0;
			} else {
				3;
			}
		} else {
			2;
		}
	} else {
		1;
	}
}

setArrayItemI32(arrayAdr : i32, index : i32, value : i32) -> () {
	store<>(arrayAdr + i32NumSize * index, value);
}