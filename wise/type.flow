import tools/dsl/dsl_typing;
import wase/type;

export {
	typeWise(ast : DslAst) -> DslAst;
}

typeWise(ast : DslAst) -> DslAst {
	deep = ref false;
	acc = makeDslTypeAcc(mergeWiseTypes, \a, n, g -> typecheckWise(a, ^deep, n, g));

	// OK, first time, we do NOT go deep, but just grab the top-level names
	dslTypeInfer(acc, ast, false) |> ignore;

//	println(getTreeKeys(^(acc.env)));
//	println(getTreeValues(^(acc.env)));

	// Then go again, but this time deep and we resolve the final type
	deep := true;
	dslTypeInfer(acc, ast, true);
}

mergeWiseTypes(acc : DslTypeAcc, left : DslAst, right : DslAst) -> DslAst {
	mergeWaseTypes(acc, left, right);
}

typecheckWise(acc : DslTypeAcc, deep : bool, node : DslAst, getChildType : (int) -> DslAst) -> DslAst {
	switch (node) {
		DslBool(__): DslString("bool");
		DslNode(name, args, pos): {
			if (name == "equal" || name == "not_equal" || name == "less_equal" || name == "less"
				|| name == "greater_equal" || name == "greater") {
				// Comparisons give bools in Wise
				left = getChildType(0);
				right = getChildType(1);
				acc.unifyTypes(acc, left, right);
				DslString("bool");
			} else if (name == "true" || name == "false") {
				DslString("bool");

			} else if (name == "ifelse") {
				cond = getChildType(0);
				acc.unifyTypes(acc, cond, DslString("bool"));

				blockType = makeDslTypeVar(acc);
				preBlocks = ^(acc.blocks);
				acc.blocks := arrayPush(preBlocks, blockType);

				thenType = getChildType(1);
				elseType = getChildType(2);
				acc.unifyTypes(acc, thenType, elseType);
				acc.unifyTypes(acc, blockType, thenType);

				acc.blocks := preBlocks;

				blockType;
			} else if (name == "if") {
				cond = getChildType(0);
				acc.unifyTypes(acc, cond, DslString("bool"));

				blockType = DslList(makeList());
				preBlocks = ^(acc.blocks);

				thenType = getChildType(1);
				acc.unifyTypes(acc, thenType, blockType);
				acc.blocks := preBlocks;

				blockType;
			} else if (name == "bool_or" || name == "bool_and") {
				left = getChildType(0);
				right = getChildType(1);
				acc.unifyTypes(acc, left, DslString("bool"));
				acc.unifyTypes(acc, right, DslString("bool"));
				DslString("bool");
			} else if (name == "while") {
				// TODO: Handle block types so we can 
				// record where "break" and "continue" should refer to 
				// so we can translate break and continue correctly
				cond = getChildType(0);
				body = getChildType(1);
				acc.unifyTypes(acc, cond, DslString("bool"));

				// The result is always void
				DslList(makeList());
			} else if (name == "break" || name == "continue") {
				// The result is always void
				DslList(makeList());
			} else {
				// OK, we just reuse typing from Wase
				typecheckWase(acc, deep, node, getChildType);
			}
		}
		default: typecheckWase(acc, deep, node, getChildType);
	}
}
