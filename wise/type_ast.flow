import wise/wise_types;
import wise/wiseast_types;
import ds/union_find_map;
import algorithms;

export {
	typecheckWiseAst(state : TypeWiseAstState, ast : WiseAst) -> WiseAstType;

	makeTypeWiseAstState(onError : (WiseAst, string) -> void) -> TypeWiseAstState;
}

makeTypeWiseAstState(onError : (WiseAst, string) -> void) -> TypeWiseAstState {
	TypeWiseAstState(makeTree(), makeTree(), onError, makeUnionFindMap([], \l, r -> { sortUnique(concat(l, r)) }), ref 0);
}

TypeWiseAstState(
	vars : Tree<string, WiseAstType>,
	fns : Tree<string, WiseAstTypeFunc>,
	onError : (WiseAst, string) -> void,

	unionFindMap : UnionFindMap<[WiseAstType]>, // types tree
	unique : ref int, // the last type id
);


typecheckWiseAst(state : TypeWiseAstState, ast : WiseAst) -> WiseAstType {
	rec2 = \value, ltype -> {
		t = typecheckWiseAst(state, value);
		unifyWiseAstTypes(state, ltype, t);
		t;
	}
	rec = \value -> rec2(value, getNewEclassType(state));
	rec2e = \e1, e2 -> {
		e1type = rec(e1);
		rec2(e2, e1type);
	}
	rec2b = \e1, e2 -> {
		rec2e(e1, e2);
		WiseAstTypeBool();
	}
	basicType2WiseAstType = \s -> {
		if (s == "i32") WiseAstTypeI32()
		else if (s == "i64") WiseAstTypeI64()
		else if (s == "f32") WiseAstTypeF32()
		else if (s == "f64") WiseAstTypeF64()
		else if (s == "v128") WiseAstTypeSIMD()
		else {
			println("ERROR: unknown basic type " + s);
			WiseAstTypeEclass(-1);
		}
	}
	checkBitwiseOp = \exp1, exp2 -> {
		type = rec2e(exp1, exp2);
		if (type != WiseAstTypeI32() && type != WiseAstTypeI64()) {
			state.onError(ast, "bitwise operation only works on i32 and i64")
		}
		type;
	}

	switch (ast : WiseAst) {
		WiseAstList(value): foldList(value, WiseAstTypeEclass(-1), \__, v -> rec(v));
		WiseAstBool(__): WiseAstTypeBool();
		WiseAstInt(__): WiseAstTypeI32();
		WiseAstDouble(__): WiseAstTypeF64();
		WiseAstString(__): WiseAstTypeString();
		WiBool(__, __): WiseAstTypeBool();
		WiBreak(eclass): WiseAstTypeEclass(eclass);
		WiContinue(eclass): WiseAstTypeEclass(eclass);
		WiDouble(__, __): WiseAstTypeF64();
		WiHex32(__, __): WiseAstTypeI32();
		WiHex64(__, __): WiseAstTypeI64();
		WiHexf32(__, __): WiseAstTypeF32();
		WiHexf64(__, __): WiseAstTypeF64();
		WiI64(__, __): WiseAstTypeI64();
		WiInt(__, __): WiseAstTypeI32();
		WiIf(cond, val, __): {
			rec2(cond, WiseAstTypeBool());
			rec(val);
		}
		WiIfelse(cond, ifval, elseval, __): {
			rec2(cond, WiseAstTypeBool());
			rec2e(elseval, ifval);
		}
		WiReturn(exps, eclass): {
			if (exps == []) {
				println("ERROR : WiReturn doesn't containt values");
				WiseAstTypeEclass(eclass);
			} else {
				fold(exps, WiseAstTypeEclass(eclass), \__, v -> rec(v));
			}
		}
		WiSet(id, e, eclass): {
			vtype = lookupTree(state.vars, id);
			vtype ?? {
				rec2(e, vtype)
			} : {
				state.onError(ast, "can't find variable '" + id + "' to check types");
				WiseAstTypeEclass(eclass);
			}
		}
		WiTuple(exps, __): WiseAstTypeTuple(map(exps, rec));
		WiVar(id, eclass): {
			vtype = eitherFn(lookupTree(state.vars, id), \t -> Some(t), \-> lookupTree(state.fns, id));
			vtype ?? {
				vtype
			} : {
				state.onError(ast, "ERROR : variable type is not found : " + id);
				WiseAstTypeEclass(eclass);
			}
		}
		WiWhile(cond, body, __): {
			rec2(cond, WiseAstTypeBool());
			rec(body);
		}
		WiFunction(optexport, id, templates, lambdaargs, type, e, decl, eclass): {
			retType = rec(type);
			fnType = WiseAstTypeFunc(map(lambdaargs, \a -> rec(a.type)), retType);
			newState = TypeWiseAstState(state with 
				fns = setTree(state.fns, id, fnType),
				vars = fold(lambdaargs, state.vars, \acc, t -> setTree(acc, t.id, rec(t.type)))
			);
			bodyType = typecheckWiseAst(newState, e);
			unifyWiseAstTypes(state, bodyType, retType);
			declType = typecheckWiseAst(newState, decl);
			unifyWiseAstTypes(state, getNewEclassType(state), declType);
			fnType;
		}
		WiGlobal(id, optexport, type, optmutable, e, decl, eclass): {
			rec(decl);
			rec(e);
		}
		WiImport(id1, type, optmutable, id2, id3, decl, eclass): {
			rec(decl);
			rec(type);
		}
		WiWaseEmpty(eclass): WiseAstTypeEclass(eclass);
		WiWiseInclude(s, decl, eclass): rec(decl);
		WiAdd(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiAnd(exp1, exp2, eclass): checkBitwiseOp(exp1, exp2);
		WiBoolAnd(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiDiv(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiMod(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiMul(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiBoolOr(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiOr(exp1, exp2, eclass): checkBitwiseOp(exp1, exp2);
		WiSub(exp1, exp2, eclass): rec2e(exp1, exp2);
		WiXor(exp1, exp2, eclass): checkBitwiseOp(exp1, exp2);
		WiBrace(expsemi, eclass): {
			if (expsemi == []) {
				WiseAstTypeEclass(eclass);
			} else {
				fold(expsemi, WiseAstTypeEclass(eclass), \__, v -> rec(v));
			}
		}
		WiCall(fn, args, eclass): {
			targs = map(args, rec);
			result = getNewEclassType(state);
			callType = WiseAstTypeFunc(targs, result);

			/* tfn = switch (fn : WiExp) {
				WiVar(id, __): {
					mtype = typeBuiltin(env, id); // native
					mtype ?? {
						unifyTypes(env, mtype, tv);
						mtype
					} : {
						typecheckWiseAst(state, fn);
					}
				}
				default: typecheckWiseAst(state, fn);
			}; */
			rec2(fn, callType);
		}
		WiEqual(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiGreater(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiGreaterEqual(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiGreaterEqualu(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiGreateru(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiIsNull(e, eclass): {
			rec(e);
			WiseAstTypeBool();
		}
		WiLess(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiLessEqual(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiLessEqualu(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiLessu(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiNotEqual(exp1, exp2, eclass): rec2b(exp1, exp2);
		WiBoolNot(e, eclass): rec2(e, WiseAstTypeBool());
		WiLet(id, i, opttype, e, brace, eclass): {
			varType = rec(opttype);
			newState = TypeWiseAstState(state with vars = setTree(state.vars, id, varType));
			eType = typecheckWiseAst(newState, e);
			unifyWiseAstTypes(state, eType, varType);

			typecheckWiseAst(newState, brace);
		}
		WiNegate(e, eclass): rec(e);
		
		WiTupledot(e, ind, eclass): {
			et = rec(e);
			switch (et : WiseAstType) {
				WiseAstTypeTuple(types): {
					if (existsIndex(types, ind)) {
						types[ind]
					} else {
						println("ERROR : can't find field " + i2s(ind) + " in Tuple : " + toString(types));
						WiseAstTypeEclass(eclass);
					}
				}
				default : {
					println("ERROR : can't extract field type from Tuple : " + toString(et));
					WiseAstTypeEclass(eclass);
				}
			}
		}
		WiTypeannotation(e, type, eclass): {
			ttype = rec(type);
			rec2(e, ttype);
		}
		WiWasmOp(s, wargs, exps, eclass): {
			iter(wargs, \v -> rec(v)|> ignore);
			fold(exps, WiseAstTypeEclass(eclass), \__, v -> rec(v));
		}
		WiBasictype(s, eclass): basicType2WiseAstType(s);
		WiFntype(types, type, eclass): WiseAstTypeFunc(map(types, rec), rec(type));
		WiTupletype(types, eclass): WiseAstTypeTuple(map(types, rec));
		WiIdtype(id, type, eclass): rec(type);
		WiSizeoftype(type, eclass): WiseAstTypeI32();
		WiPolycall(e, types, eclass): {
			println("WiPolycall is not implemented"); // decomposition should be done before
			rec(e);
		}
		WiDefoftype(type, eclass) : rec(type);
	}
}

getNewEclassType(env : TypeWiseAstState) -> WiseAstType {
	id = ^(env.unique);
	env.unique := id + 1;
	WiseAstTypeEclass(id);
}

unifyWiseAstTypes(env : TypeWiseAstState, left : WiseAstType, right : WiseAstType) -> void {
	if (left != right) {
		onError = \ -> {
			env.onError(WiWaseEmpty(0), "ERROR: " + toString(left) + " is not compatible with " + toString(right));
		};
		doRight = \ -> {
			switch (right : WiseAstType) {
				WiseAstTypeEclass(__): unifyWiseAstTypes(env, right, left);
				default: onError();
			}
		};
		bindTyvar = \tyvar, type -> {
			types = getUnionMapValue(env.unionFindMap, tyvar);
			ntypes = sortUnique(arrayPush(types, type));
			setUnionMapValue(env.unionFindMap, tyvar, ntypes);
		}
		switch (left : WiseAstType) {
			WiseAstTypeEclass(lid): {
				switch (right : WiseAstType) {
					WiseAstTypeEclass(rid): {
						// println("Unifying " + i2s(lid) + " and " + i2s(rid));
						root = unionUnionMap(env.unionFindMap, lid, rid);
					}
					WiseAstTypeFunc(__, __): {
						unifyWiseAstTypes(env, right, left);
					}
					WiseAstTypeTuple(__): {
						unifyWiseAstTypes(env, right, left); // ?
					}
					default: {
						bindTyvar(lid, right);
					}
				}
			}
			WiseAstTypeBool(): doRight();
			WiseAstTypeI32(): doRight();
			WiseAstTypeI64(): doRight();
			WiseAstTypeF32(): doRight();
			WiseAstTypeF64(): doRight();
			WiseAstTypeString(): doRight();
			WiseAstTypeSIMD(): doRight();
			WiseAstTypeTuple(ltypes): {
				switch (right : WiseAstType) {
					WiseAstTypeTuple(rtypes): {
						if (length(ltypes) != length(rtypes)) {
							onError();
						} else {
							iteri(ltypes, \i, ltype -> unifyWiseAstTypes(env, ltype, rtypes[i]));
						}
					}
					WiseAstTypeEclass(id): {
						rtypes = mapi(ltypes, \i, ltype -> getNewEclassType(env));
						rt = WiseAstTypeTuple(rtypes);
						bindTyvar(id, rt);
						unifyWiseAstTypes(env, left, rt)
					}
					default: onError();
				}
			}
			WiseAstTypeFunc(largs, lreturnType): {
				switch (right : WiseAstType) {
					WiseAstTypeFunc(rargs, rreturnType): {
						if (length(largs) != length(rargs)) {
							onError();
						} else {
							iteri(largs, \i, larg -> {
								unifyWiseAstTypes(env, larg, rargs[i]);
							});
						}
						unifyWiseAstTypes(env, lreturnType, rreturnType);
					}
					WiseAstTypeEclass(id): {
						retTyvar = getNewEclassType(env);
						argTyvars = map(largs, \__ -> getNewEclassType(env));
						rt = WiseAstTypeFunc(argTyvars, retTyvar);
						bindTyvar(id, rt);
						unifyWiseAstTypes(env, left, rt)
					}
					default: onError();
				}
			}
		}
	}
}