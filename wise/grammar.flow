import tools/dsl/dsl_parse;

export {
	defineWise() -> DslGrammar;	
}

defineWise() -> DslGrammar {
	grammar = defineGrammar("wise", <<
		decl = import | include | global | function | $"wase_empty_0";

		global = optexport id $"swap" 
				":" ws optmutable type $"swap"
				"=" ws exp ";" ws decl $"global_6"; // (id, export : bool, type, mutable : bool, exp, body, scope)

		// function(id, export : bool, args : [idtype(id, type)], [returnTypes], body, scope)
		function = optexport id $"swap" "(" ws lambdaargs ")" ws "->" ws type exp decl $"function_6"; // The "" makes right-recursion disappear
			lambdaargs = $"nil" id ":" ws type $"idtype_2" $"cons" ("," ws id ":" ws type $"idtype_2" $"cons")*
				| $"nil";

		import = 
			"import" ws id ":" ws optmutable type $"swap" "=" ws id "." id ";" ws decl $"import_6" // id, type, mutable, module, name, scope
			;
			
		include = "include" !letterOrDigit ws $(letterOrDigit+ ("/" letterOrDigit+)+) ws ";" ws decl $"wise_include_2";

		exp = 
			("var" !letterOrDigit ws $$"1" $"s2i" id $"swap" opttype "=" ws exp ";" ws expsemi $"brace_1" $"let_5"
			 | id $$"0" $"s2i" opttype "=" ws exp ";" ws expsemi $"brace_1" $"let_5"
			)
			|> exp "||" ws exp $"bool_or_2"
			|> exp "&&" ws exp $"bool_and_2"
			|> exp "|" ws exp $"or_2"
			|> exp "&" ws exp $"and_2"
			|> exp "^" ws exp $"xor_2"
			|> exp "==" ws exp $"equal_2" | exp "!=" ws exp $"not_equal_2" | exp "is" ws "null" ws $"is_null_1"
			|> exp ("<=" ws exp $"less_equal_2" | "<" ws exp $"less_2" | ">=" ws exp $"greater_equal_2" | ">" ws exp $"greater_2")

			|> exp < ("+" ws exp $"add_2" | "-" ws exp $"sub_2")*
			|> exp ("*" ws exp $"mul_2" | "/" ws exp $"div_2" | "%"  ws exp $"mod_2")*

			|> exp ':' ws type $"typeannotation_2"

			|> wasmop

			|> (
				'!' ws exp $"bool_not_1"
				| "-" ws exp $"negate_1" // Only for floats
				| exp (
					postfix
				)*
			)

			|> brace $"brace_1"
			|> "(" ws exp ")" ws
			|> atom;

		// Give this a name, so it can be extended
		postfix = ( "(" ws exps ")" ws $"call_2");

		opttype = ":" ws type | $$"auto" $"type_1";

		brace = "{" ws expsemi "}" ws;

		atom = "if" !letterOrDigit ws exp exp "else" ws exp $"ifelse_3"
				| "if" !letterOrDigit ws exp exp $"if_2"
				| "true" !letterOrDigit $"true_0" ws
				| "false" !letterOrDigit $"false_0" ws
				| "return" !letterOrDigit ws (exp | $"nil") $"return_1"
				| "while"  !letterOrDigit ws "(" ws exp ")" ws exp $"while_2"
				| "break" !letterOrDigit ws $"break_0"
				| "continue" !letterOrDigit ws $"continue_0" 
				| id ":=" ws exp $"set_2"
				| id $"var_1"
				| '[' ws exps ']' ws // list
//				| string $"string_1"
				| "0x" $(hexdigit+) ("w" $"hex64_1" | "n" $"hexf32_1" | "h" $"hexf64_1" | $"hex32_1") ws
				| $('0'-'9'+) "w" ws $"i64_1"
				| double $"double_1"
				| int $"int_1"
				// | '<<' $(!('>' '>') anychar)* ('>' '>') ws
				;

		wasmop = $wasmid ws "<" ws wargs ">" ws "(" ws exps ")" ws $"wasm_op_3";
			wargs = $"nil" warg $"cons"("," ws warg $"cons")* | $"nil";
			warg = type | id | int;

			wasmid = 'a'-'z' wasmidpart* ("." wasmidpart+)?;
			wasmidpart = 'a'-'z' | '0'-'9' | "_";

		exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)? 
			| $"nil";

		expsemi = $"nil" exp $"cons" (#";" ws exp $"cons")* (";" ws)? 
			| $"nil";

		optexport = "export" ws (string | $$"1" $"s2i") | ($$"0" $"s2i");

		optmutable = ("mutable" ws $$"1" | $$"0" ) $"s2i";

		type = $("i32" | "i64" | "f32" | "f64" | "v128" | "bool" | "auto") ws $"type_1"
			| "(" ws types ")" ws "->" ws type $"fntype_2"
			| "(" ws types ")" ws;
		
		types = $"nil" type $"cons" ("," ws type $"cons")* | $"nil";

		ws decl
	>>, ["ws", "id", "int", "double", "string"]); // true adds definitions for whitespace

	grammar;
}
