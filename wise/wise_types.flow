// Automatically generated from Gringo grammar
export {
	Atom ::= Bool, Break, Continue, Double, Hex32, Hex64, Hexf32, Hexf64, I64, If, Ifelse, Int, Return, Set, Tuple, Var, While;
	Decl ::= Function, Global, Import, WaseEmpty, WiseInclude;
	Exp ::= Add, And, Atom, BoolAnd, BoolNot, BoolOr, Brace, Call, Div, Equal, Greater, GreaterEqual, GreaterEqualu, Greateru, IsNull, Less, LessEqual, LessEqualu, Lessu, Let, Mod, Mul, Negate, NotEqual, Or, Sub, Tupledot, Typeannotation, WasmOp, Xor;
	Optexport(v : string);
	Type ::= Basictype, Fntype, Tupletype;
	Warg ::= Int, Var, Type;
	Add(exp1 : Exp, exp2 : Exp);
	And(exp1 : Exp, exp2 : Exp);
	Basictype(s : string);
	Bool(b : bool);
	BoolAnd(exp1 : Exp, exp2 : Exp);
	BoolNot(exp : Exp);
	BoolOr(exp1 : Exp, exp2 : Exp);
	Brace(expsemi : [Exp]);
	Break();
	Call(exp : Exp, exps : [Exp]);
	Continue();
	Div(exp1 : Exp, exp2 : Exp);
	Double(d : Double);
	Equal(exp1 : Exp, exp2 : Exp);
	Fntype(types : [Type], type : Type);
	Function(id : string, optexport : Optexport, lambdaargs : [Idtype], type : Type, exp : Exp, decl : Decl);
	Global(id : string, optexport : Optexport, type : Type, optmutable : int, exp : Exp, decl : Decl);
	Greater(exp1 : Exp, exp2 : Exp);
	GreaterEqual(exp1 : Exp, exp2 : Exp);
	GreaterEqualu(exp1 : Exp, exp2 : Exp);
	Greateru(exp1 : Exp, exp2 : Exp);
	Hex32(s : string);
	Hex64(s : string);
	Hexf32(s : string);
	Hexf64(s : string);
	I64(s : string);
	Idtype(id : string, type : Type);
	If(exp1 : Exp, exp2 : Exp);
	Ifelse(exp1 : Exp, exp2 : Exp, exp3 : Exp);
	Import(id1 : string, type : Type, optmutable : int, id2 : string, id3 : string, decl : Decl);
	Int(i : Int);
	IsNull(exp : Exp);
	Less(exp1 : Exp, exp2 : Exp);
	LessEqual(exp1 : Exp, exp2 : Exp);
	LessEqualu(exp1 : Exp, exp2 : Exp);
	Lessu(exp1 : Exp, exp2 : Exp);
	Let(id : string, i : int, opttype : Type, exp : Exp, brace : Brace);
	Mod(exp1 : Exp, exp2 : Exp);
	Mul(exp1 : Exp, exp2 : Exp);
	Negate(exp : Exp);
	NotEqual(exp1 : Exp, exp2 : Exp);
	Or(exp1 : Exp, exp2 : Exp);
	Return(exps : [Exp]);
	Set(id : string, exp : Exp);
	Sub(exp1 : Exp, exp2 : Exp);
	Tuple(exps : [Exp]);
	Tupledot(exp : Exp, i : Int);
	Tupletype(types : [Type]);
	Typeannotation(exp : Exp, type : Type);
	Var(id : string);
	WaseEmpty();
	WasmOp(s : string, wargs : [Warg], exps : [Exp]);
	While(exp1 : Exp, exp2 : Exp);
	WiseInclude(s : string, decl : Decl);
	Xor(exp1 : Exp, exp2 : Exp);
}
