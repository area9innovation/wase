import wase/wase_types;
import wise/type_ast;
import wise/wiseast_dot;
import wise/wiseast_utils;

export {
	lowerWiseAst2WaseAst(w : WiseAst, typeEnv : TypeWiseAstState, dots : ref Set<WaseDotFn>) -> WaseAst;
	lowerTuplesInWiseAst(ast : WiseAst, unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> WiseAst;
}

LowerWiseAstEnv(
	blocks : int,
	loops : [int],
	locals : Tree<string, WiType>,
	fns : Tree<string, WiType>, // returnType
	dots : ref Set<WaseDotFn>,
	typeEnv : TypeWiseAstState,
	tmpCntr : ref int,
	onError : (WiseAst, string) -> void, 
);

makeLowerWiseAstEnv() -> LowerWiseAstEnv {
	LowerWiseAstEnv(0, [], makeTree(), makeTree(), ref makeSet(), makeTypeWiseAstState(nop2), ref 0, nop2);
}

lowerWiseAst2WaseAst(w : WiseAst, typeEnv : TypeWiseAstState, dots : ref Set<WaseDotFn>) -> WaseAst {
	env = LowerWiseAstEnv(makeLowerWiseAstEnv() with
		fns = extractFnNamesFromWiseAst(w, makeTree()),
		typeEnv = typeEnv,
		dots = dots,
		onError = \ast, error -> println(error + " at: " + toString(ast))
	);
	lowerWiseAstToWaseAst(env, w);
}

lowerWiseAstToWaseAst(env : LowerWiseAstEnv, w : WiseAst) -> WaseAst {
	rec = \w1 -> lowerWiseAstToWaseAst(env, w1);

	switch (w) {
		WiseAstList(value): WaseAstList(mapList(value, rec));
		WiseAstBool(value): WaseAstBool(value);
		WiseAstInt(value): WaseAstInt(value);
		WiseAstDouble(value): WaseAstDouble(value);
		WiseAstString(value): WaseAstString(value);
		WiExp(): WiExp2WeExp(env, w);
		WiDecl(): WiDecl2WeDecl(env, w);
		WiType(): WiType2WeType(w);
		WiIdtype(__, __, __): WiIdtype2WeIdtype(w);
	}
}

WiIdtype2WeIdtype(w : WiIdtype) -> WeIdtype {
	WeIdtype(w.id, WiType2WeType(w.type));
}

WiDecl2WeDecl(env : LowerWiseAstEnv, w : WiDecl) -> WeDecl {
	lowerExp = \exp -> WiExp2WeExp(env, exp);
	lowerDecl = \decl -> WiDecl2WeDecl(env, decl);
	switch (w : WiDecl) {
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl, __): {
			newEnv = LowerWiseAstEnv(env with locals = fold(lambdaargs, env.locals, \acc, t -> setTree(acc, t.id, t.type)));
			WeFunction(id, optexport, map(lambdaargs, WiIdtype2WeIdtype), WiType2WeTypes(type), WiExp2WeExp(newEnv, expr), lowerDecl(decl));
		}
		WiGlobal(id, optexport, type, optmutable, expr, decl, __): {
			WeGlobal(id, optexport, WiType2WeType(type), optmutable, lowerExp(expr), lowerDecl(decl));
		}
		WiImport(id1, type, optmutable, id2, id3, decl, __): {
			makeGlobalImport = \-> WeImportGlobal(id1, WiType2WeType(type), optmutable, id2, id3, lowerDecl(decl));
			switch(type : WiType) {
				WiFntype(types, type0, __): WeImportFun(id1, WeFnType(map(types, WiType2WeType), WiType2WeTypes(type0)), id2, id3, lowerDecl(decl));
				WiBasictype(__, __) : makeGlobalImport();
				WiTupletype(__, __) : makeGlobalImport();
			}
		}
		WiWiseInclude(s, decl, __): WeWaseInclude(s, lowerDecl(decl));
		WiWaseEmpty(__): WeWaseEmpty();
	}
}

WiWarg2WeWarg(w : WiWarg) -> WeWarg {
	switch (w : WiWarg) {
		WiInt(int_0, __): WeInt(int_0);
		WiVar(id, __): WeString(id);
		WiType(): WiType2WeType(w);
	}
} 

WiExp2WeExp(env : LowerWiseAstEnv, w : WiExp) -> WeExp {
	rec = \w1 -> WiExp2WeExp(env, w1);
	// TODO : (1>0 && 4>0) -> bool!=i32 (greater - bool, boolean - i32)
	switch (w : WiExp) {
		WiAdd(exp1, exp2, __): WeAdd(rec(exp1), rec(exp2));
		WiAnd(exp1, exp2, __): WeAnd(rec(exp1), rec(exp2));
		WiBool(b, __): WeInt(if (b) 1 else 0);
		WiBreak(__): {
			depth = (env.blocks - 1) - (if (env.loops == []) {
				env.onError(w, "break only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("break", [WeInt(depth)], []); // exps?
		}
		WiContinue(__): {
			depth = (env.blocks - 2) - (if (env.loops == []) {
				env.onError(w, "continue only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("continue", [WeInt(depth)], []); // exps?
		}
		WiDouble(double_0, __): WeDouble(double_0);
		WiHex32(s, __): WeHex32(s);
		WiHex64(s, __): WeHex64(s);
		WiHexf32(s, __): WeHexf32(s);
		WiHexf64(s, __): WeHexf64(s);
		WiI64(s, __): WeI64(s);
		WiIf(exp1, exp2, __): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			WeIf(cond, then);
		}
		WiIfelse(exp1, exp2, exp3, __): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			elsec = WiExp2WeExp(nenv, exp3);
			WeIfelse(cond, then, elsec);
		}
		WiInt(int_0, __): WeInt(int_0);
		WiReturn(exps, __): WeReturn(WeBrace(map(exps, rec)));
		WiSet(id, e, __): WeSet(id, rec(e));
		WiTuple(exps, __): WeTuple(map(exps, rec));
		WiVar(id, __): {
			if (containsKeyTree(env.fns, id) && !containsKeyTree(env.locals, id)) {
				WeWasmOp("fn", [WeString(id)], [])
			} else {
				WeVar(id)
			}
		}
		WiWhile(exp1, exp2, __): {
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 2, loops = arrayPush(env.loops, env.blocks));
			// while (cond) { <exp> } =>
			// block { loop { break_if<2>(!cond); <exp>; break<>() } }
			// cond, exp, type = void
			cond = WiExp2WeExp(nenv, exp1);
			body = WiExp2WeExp(nenv, exp2);
			WeBlock([
				WeLoop([
					WeWasmOp(
						"break_if", 
						[WeInt(1)], 
						[WeBoolNegate(cond)]), 
					body, 
					WeWasmOp("break", [], [])
				])
			])
		}
		WiBoolAnd(exp1, exp2, __): WeIfelse(rec(exp1), rec(exp2), makeWeFalse()); // TODO: If a does not have side-effects, we can do a bitwise and
		WiBoolNot(e, __): WeIfelse(rec(e), makeWeFalse(), makeWeTrue());
		WiBoolOr(exp1, exp2, __): WeIfelse(rec(exp1), makeWeTrue(), rec(exp2)); // TODO: If a does not have side-effects, we can do a bitwise or
		WiBrace(expsemi, __): WeBrace(map(expsemi, rec));
		WiCall(e, exps, __): {
			indirect = \fncall -> {
				fnargs = map(exps, rec);
				// swap fnargs and fnname (due to DSL ?)
				WeWasmOp("call_indirect", [], arrayPush(fnargs, fncall))
			};
			fnId = getWiVarId(e);
			if (fnId == "") {
				indirect(rec(e));
			} else {
				if (containsKeyTree(env.locals, fnId)) {
					indirect(WeVar(fnId))
				} else {
					WeCall(WeVar(fnId), map(exps, rec))
				}
			}
		}
		WiDiv(exp1, exp2, __): WeDiv(rec(exp1), rec(exp2));
		WiEqual(exp1, exp2, __): WeEqual(rec(exp1), rec(exp2));
		WiGreater(exp1, exp2, __): WeGreater(rec(exp1), rec(exp2));
		WiGreaterEqual(exp1, exp2, __): WeGreaterEqual(rec(exp1), rec(exp2));
		WiGreaterEqualu(exp1, exp2, __): WeWasmOp("ge_u", [], [rec(exp1), rec(exp2)]);
		WiGreateru(exp1, exp2, __): WeWasmOp("gt_u", [], [rec(exp1), rec(exp2)]);
		WiIsNull(e, __): WeIsNull(rec(e));
		WiLess(exp1, exp2, __): WeLess(rec(exp1), rec(exp2));
		WiLessEqual(exp1, exp2, __): WeLessEqual(rec(exp1), rec(exp2));
		WiLessEqualu(exp1, exp2, __): WeWasmOp("le_u", [], [rec(exp1), rec(exp2)]);
		WiLessu(exp1, exp2, __): WeWasmOp("lt_u", [], [rec(exp1), rec(exp2)]);
		WiLet(id, i, opttype, e, brace, __): wiLet2weLet(env, w);
		WiMod(exp1, exp2, __): WeMod(rec(exp1), rec(exp2));
		WiMul(exp1, exp2, __): WeMul(rec(exp1), rec(exp2));
		WiNegate(e, __): WeNegate(rec(e));
		WiNotEqual(exp1, exp2, __): WeNotEqual(rec(exp1), rec(exp2));
		WiOr(exp1, exp2, __): WeOr(rec(exp1), rec(exp2));
		WiSub(exp1, exp2, __): WeSub(rec(exp1), rec(exp2));
		WiTypeannotation(e, type, __): WeTypeAnnotation(rec(e), WiType2WeTypes(type));
		WiWasmOp(s, wargs, exps, __): WeWasmOp(s, map(wargs, WiWarg2WeWarg), map(exps, rec));
		WiXor(exp1, exp2, __): WeXor(rec(exp1), rec(exp2));
		WiSizeoftype(type, __): WeInt(0);
		WiPolycall(e, types, __): rec(e);
		WiTupledot(e, int_0, __): tupledot2WeAst(env, w);
		WiDefoftype(type, __): WeInt(0);
	}
}

getWiVarId(e : WiseAst) -> string {
	switch (e : WiseAst) {
		WiVar(id, __):  id;
		default: "";
	}
}

makeWeFalse() -> WeExp {
	WeInt(0); // WeEqual(WeInt(0), WeInt(1));
}
makeWeTrue() -> WeExp {
	WeInt(1); // WeEqual(WeInt(1), WeInt(1));
}

WeBoolNegate(b : WeExp) -> WeExp {
	onError = \ -> {
		// println("can't negate the non-bool value : " + toString(b));
		WeIfelse(b, makeWeFalse(), makeWeTrue());
	}
	switch (b : WeExp) {
		WeNotEqual(e1, e2) : WeEqual(e1, e2);
		WeEqual(e1, e2) : WeNotEqual(e1, e2);
		WeGreater(e1, e2) : WeLessEqual(e1, e2);
		WeGreaterEqual(e1, e2) : WeLess(e1, e2);
		WeLess(e1, e2) : WeGreaterEqual(e1, e2);
		WeLessEqual(e1, e2) : WeGreater(e1, e2);
		WeAnd(__, __) : onError();
		WeOr(__, __) : onError();
		WeXor(__,__) : onError();
		WeAdd(__, __) : onError();
		WeSub(__, __) : onError();
		WeMul(__, __) : onError();
		WeDiv(__, __) : onError();
		WeMod(__, __) : onError();
		WeNegate(__) : onError();
		WeTypeAnnotation(__, __) : onError();
		WeWasmOp(__, __, __) : onError();
		WeAtom() : onError();
		WeBrace(__) : onError();
		WeCall(__, __) : onError();
		WeCall2(__, __) : onError();
		WeLet(__, __, __, __, __) : onError();
		WeLettuple(__, __, __, __, __) : onError();
		WeIsNull(__) : onError();
	}
}

WiType2WeType(w : WiType) -> WeType {
	rec = \w1 -> WiType2WeType(w1);
	switch (w : WiType) {
		WiBasictype(s, __): WeType(s);
		WiFntype(types, type, __): WeType("i32");
		WiTupletype(types, __): if (types == []) WeType("") else rec(types[0]); // TODO
	}
}

WiType2WeTypes(w : WiType) -> [WeType] {
	unrollAndMapWiType(w, \t -> WeType(t.s));
}

unrollAndMapWiType(w : WiType, fn : (WiBasictype) -> ?) -> [?] {
	switch (w : WiType) {
		WiBasictype(s, __): [fn(w)];
		WiFntype(types, type, __): concat(fold(types, [], \acc, t -> concat(acc, unrollAndMapWiType(t, fn))), unrollAndMapWiType(type, fn));
		WiTupletype(types, __): fold(types, [], \acc, t -> concat(acc, unrollAndMapWiType(t, fn)));
	}
}

wiLet2weLet(env : LowerWiseAstEnv, w : WiLet) -> WeExp {
	newEnv = LowerWiseAstEnv(env with 
		locals = setTree(env.locals, w.id, w.opttype),
		typeEnv = TypeWiseAstState(env.typeEnv with vars = setTree(env.typeEnv.vars, w.id, resolveWiseAstTypeByEclass(env.typeEnv.unionFindMap, w.opttype.eclass, env.onError)))
	);
	recE = \w1 -> WiExp2WeExp(newEnv, w1);
	rec = \w1 -> WiExp2WeExp(env, w1);
	makeLetVar = \-> WeLet(w.id, w.i, WiType2WeType(w.opttype), rec(w.exp), WeBrace(map(w.brace.expsemi, recE)));
	switch (w.opttype : WiType) {
		WiBasictype(__, __): makeLetVar();
		WiFntype(__, __, __): makeLetVar();
		WiTupletype(__, __): wiLet2weLettuple(newEnv, w, w.opttype);
	}
}

wiLet2weLettuple(env : LowerWiseAstEnv, w : WiLet, ttype : WiTupletype) -> WeExp {
	recE = \w1 -> WiExp2WeExp(env, w1);
	WeLettuple(
		w.id,
		w.i,
		WiType2WeTypes(w.opttype),
		recE(w.exp),
		WeBrace(map(w.brace.expsemi, recE))
	);
}

extractFnNamesFromWiseAst(w : WiseAst, acc : Tree<string, WiType>,) -> Tree<string, WiType> {
	switch (w) {
		WiseAstList(value): foldList(value, acc, \acc2, v -> extractFnNamesFromWiseAst(v, acc2));
		WiseAstBool(__): acc;
		WiseAstInt(__): acc;
		WiseAstDouble(__): acc;
		WiseAstString(__): acc;
		WiExp(): acc;
		WiType(): acc;
		WiIdtype(__, __, __): acc;
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl, __): extractFnNamesFromWiseAst(decl, setTree(acc, id, type));
		WiGlobal(id, optexport, type, optmutable, expr, decl, __): extractFnNamesFromWiseAst(decl, acc);
		WiImport(id1, type, optmutable, id2, id3, decl, __): extractFnNamesFromWiseAst(decl, acc);
		WiWaseEmpty(__): acc;
		WiWiseInclude(s, decl, __): extractFnNamesFromWiseAst(decl, acc);
	}
}

wiFieldPath2index(route : [int], types : WiseAstType, acc : int) -> int {
	if (route == []) {
		acc;
	} else {
		pathLength = ref -1;
		foundItem = findItemInWiTypes(types, [], \itemPath, __ -> {
			pathLength := ^pathLength + 1;
			itemPath == route;
		});
		if (foundItem) ^pathLength else -1;
	}
}

// todo: tail recursion
findItemInWiTypes(v : WiseAstType, route : [int], fn : ([int], WiseAstType) -> bool) -> bool {
	switch (v : WiseAstType) {
		WiseAstTypeI32() : fn(route, v);
		WiseAstTypeI64() : fn(route, v);
		WiseAstTypeF32() : fn(route, v);
		WiseAstTypeF64() : fn(route, v);
		WiseAstTypeFunc(__, __) : fn(route, v);
		WiseAstTypeSIMD() : fn(route, v);
		WiseAstTypeBool() : fn(route, v);
		WiseAstTypeString() : fn(route, v);
		WiseAstTypeEclass(__) : fn(route, v);
		WiseAstTypeTuple(types) : foldi(types, false, \i, acc, item ->
			acc || findItemInWiTypes(item, arrayPush(route, i), fn)
		);
	}
}

tupledot2WeAst(env : LowerWiseAstEnv, d : WiTupledot) -> WeExp {
	makeDotFnAndPushToEnv = \value, index, types -> {
		dotVal = extractWiExpFromWiseAst(typeWiseAst(env.typeEnv, extractNotTupleDot(value)));
		dot = makeWeTupleDotFn(dotVal, index, types, env.tmpCntr, env.typeEnv.unionFindMap);
		env.dots := insertSet(^(env.dots), dot.fn);
		WiExp2WeExp(env, dot.value);
	}
	untriple(makeTupledotData(env, d, []), \varNameM, types, path -> {
		index = wiFieldPath2index(path, types, -1);
		eitherFn(
			varNameM,
			\varName -> {
				if (index > -1) {
					WeVar(varName + "." + i2s(index));
				} else {
					env.onError(d, "ERROR: wrong index of tuple " + toString(path));
					WiExp2WeExp(env, d.exp);
				}
			},
			\-> {
				if (index < 0) {
					env.onError(d, "ERROR: wrong index of tuple " + toString(path) + " " + toString(types));
					WiExp2WeExp(env, d.exp);
				} else {
					makeDotFnAndPushToEnv(d.exp, index, types);
				}
			}
		);
	});
}

extractWiExpFromWiseAst(e : WiseAst) -> WiExp {
	switch (e : WiseAst) {
		WiExp() : e;
		default : {
			println("can't extract expression from WiseAst: " + toString(e));
			WiBrace([], 0);
		}
	}
}

extractNotTupleDot(e : WiExp) -> WiExp {
	switch (e : WiExp) {
		WiTupledot(e2, __, __): extractNotTupleDot(e2);
		default : e;
	}
}

// TODO: construct?, fnResult
makeTupledotData(env : LowerWiseAstEnv, e : WiExp, indexes : [int]) -> Triple<Maybe<string>, WiseAstType, [int]> {
	rec = \e2 -> resolveWiseAst(env.typeEnv.unionFindMap, e2, env.onError);
	defType = WiseAstTypeEclass(-1);
	switch (e : WiExp) {
		WiTupledot(e1, ind, __): makeTupledotData(env, e1, concat([ind], indexes));
		WiTuple(exps, eclass) : Triple(None(), rec(e), indexes);
		WiVar(id, __) : Triple(Some(id), eitherMap(lookupTree(env.locals, id), rec, defType), indexes);
		WiCall(e1, __, __) : Triple(None(), eitherMap(lookupTree(env.fns, getWiVarId(e1)), rec, defType), indexes);
		default : {
			env.onError(e, "		TODO: types for tupledot from " + toString(e));
			Triple(None(), defType, indexes);
		};
	}
}

lowerTuplesInWiseAst(ast : WiseAst, unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> WiseAst {
	rec = \v -> lowerTuplesInWiseAst(v, unionFindMap, tmpCntr);

	switch (ast : WiseAst) {
		WiseAstList(value): WiseAstList(mapList(value, rec));
		WiseAstBool(value): ast;
		WiseAstInt(value): ast;
		WiseAstDouble(value): ast;
		WiseAstString(value): ast;
		WiType() : lowerTuplesInWiType(ast);
		WiIdtype(id, t, eclass): WiIdtype(id, lowerTuplesInWiType(t), eclass);
		WiDecl() : lowerTuplesInWiDecl(ast, unionFindMap, tmpCntr);
		WiExp() : lowerTuplesInWiExp(ast, unionFindMap, tmpCntr);
	}
}

lowerTuplesInWiDecl(v : WiDecl, unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> WiDecl {
	switch (v : WiDecl) {
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl, eclass): WiFunction(
			optexport,
			id,
			templates,
			map(lambdaargs, \a -> WiIdtype(a.id, lowerTuplesInWiType(a.type), a.eclass)),
			lowerTuplesInWiType(type),
			lowerTuplesInWiExp(expr, unionFindMap, tmpCntr),
			lowerTuplesInWiDecl(decl, unionFindMap, tmpCntr),
			eclass
		);
		WiGlobal(id, optexport, type, optmutable, expr, decl, eclass): WiGlobal(
			id,
			optexport,
			lowerTuplesInWiType(type),
			optmutable,
			lowerTuplesInWiExp(expr, unionFindMap, tmpCntr),
			lowerTuplesInWiDecl(decl, unionFindMap, tmpCntr),
			eclass
		);
		WiImport(id1, type, optmutable, id2, id3, decl, eclass): WiImport(
			id1,
			lowerTuplesInWiType(type),
			optmutable,
			id2,
			id3,
			lowerTuplesInWiDecl(decl, unionFindMap, tmpCntr),
			eclass
		);
		WiWiseInclude(s, decl, eclass): WiWiseInclude(s, lowerTuplesInWiDecl(decl, unionFindMap, tmpCntr), eclass);
		WiWaseEmpty(__): v;

	}
}

lowerTuplesInWiType(v : WiType) -> WiType {
	switch (v : WiType) {
		WiBasictype(__, __) : v;
		WiFntype(types, type0, eclass): WiFntype(map(types, lowerTuplesInWiType), lowerTuplesInWiType(type0), eclass);
		WiTupletype(types, eclass) : WiTupletype(unrollWiTupletype(types), 0);
	}
}

unrollWiTupletype(types : [WiType]) -> [WiType] {
	mapConcat(types, \t -> switch (t : WiType) {
		WiBasictype(__, __) : [t];
		WiFntype(ttypes, type0, eclass): [WiFntype(unrollWiTupletype(ttypes), unrollWiTupletype([type0])[0], eclass)];
		WiTupletype(ttypes, eclass) : unrollWiTupletype(ttypes);
	});
}

lowerTuplesInWiExp(v : WiExp, unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> WiExp {
	rec = \v2 -> lowerTuplesInWiExp(v2, unionFindMap, tmpCntr);
	lowerTuplesInWiBrace = \v2 -> WiBrace(map(v2.expsemi, rec), v2.eclass);
	lowerTuplesInWiWarg = \v2 -> switch (v2 : WiWarg) {
		WiInt(int_0, eclass): v2;
		WiVar(id, eclass): v2;
		WiType() : lowerTuplesInWiType(v2);
	}

	switch (v : WiExp) {
		WiAdd(exp1, exp2, eclass): WiAdd(rec(exp1), rec(exp2), eclass);
		WiAnd(exp1, exp2, eclass): WiAnd(rec(exp1), rec(exp2), eclass);
		WiBool(b, __): v;
		WiBreak(__): v;
		WiContinue(__): v;
		WiDouble(__, __): v;
		WiHex32(s, __): v;
		WiHex64(s, __): v;
		WiHexf32(s, __): v;
		WiHexf64(s, __): v;
		WiI64(s, __): v;
		WiIf(exp1, exp2, eclass): WiIf(rec(exp1), rec(exp2), eclass);
		WiIfelse(exp1, exp2, exp3, eclass): WiIfelse(rec(exp1), rec(exp2), rec(exp3), eclass);
		WiReturn(exps, eclass): WiReturn(map(exps, rec), eclass);
		WiSet(id, e, eclass): WiSet(id, rec(e), eclass);
		WiTuple(exps, eclass): unrollWiTuple(v, unionFindMap, tmpCntr);
		WiWhile(exp1, exp2, eclass): WiWhile(rec(exp1), rec(exp2), eclass);
		WiBoolAnd(exp1, exp2, eclass): WiBoolAnd(rec(exp1), rec(exp2), eclass);
		WiBoolNot(e, eclass): WiBoolNot(rec(e), eclass);
		WiBoolOr(exp1, exp2, eclass): WiBoolOr(rec(exp1), rec(exp2), eclass);
		WiBrace(expsemi, eclass): lowerTuplesInWiBrace(v);
		WiCall(e, exps, eclass): WiCall(rec(e), map(exps, rec), eclass);
		WiDiv(exp1, exp2, eclass): WiDiv(rec(exp1), rec(exp2), eclass);
		WiEqual(exp1, exp2, eclass): WiEqual(rec(exp1), rec(exp2), eclass);
		WiGreater(exp1, exp2, eclass): WiGreater(rec(exp1), rec(exp2), eclass);
		WiGreaterEqual(exp1, exp2, eclass): WiGreaterEqual(rec(exp1), rec(exp2), eclass);
		WiGreaterEqualu(exp1, exp2, eclass): WiGreaterEqualu(rec(exp1), rec(exp2), eclass);
		WiGreateru(exp1, exp2, eclass): WiGreateru(rec(exp1), rec(exp2), eclass);
		WiIsNull(e, eclass): WiIsNull(rec(e), eclass);
		WiLess(exp1, exp2, eclass): WiLess(rec(exp1), rec(exp2), eclass);
		WiLessEqual(exp1, exp2, eclass): WiLessEqual(rec(exp1), rec(exp2), eclass);
		WiLessEqualu(exp1, exp2, eclass): WiLessEqualu(rec(exp1), rec(exp2), eclass);
		WiLessu(exp1, exp2, eclass): WiLessu(rec(exp1), rec(exp2), eclass);
		WiLet(id, i, opttype, e, brace, eclass): WiLet(id, i, lowerTuplesInWiType(opttype), rec(e), lowerTuplesInWiBrace(brace), eclass);// TODO ?
		WiMod(exp1, exp2, eclass): WiMod(rec(exp1), rec(exp2), eclass);
		WiMul(exp1, exp2, eclass): WiMul(rec(exp1), rec(exp2), eclass);
		WiNegate(e, eclass): WiNegate(rec(e), eclass);
		WiNotEqual(exp1, exp2, eclass): WiNotEqual(rec(exp1), rec(exp2), eclass);
		WiOr(exp1, exp2, eclass): WiOr(rec(exp1), rec(exp2), eclass);
		WiSub(exp1, exp2, eclass): WiSub(rec(exp1), rec(exp2), eclass);
		WiTypeannotation(e, type, eclass): WiTypeannotation(rec(e), lowerTuplesInWiType(type), eclass);
		WiWasmOp(s, wargs, exps, eclass): WiWasmOp(s, map(wargs, lowerTuplesInWiWarg), map(exps, rec), eclass);
		WiXor(exp1, exp2, eclass): WiXor(rec(exp1), rec(exp2), eclass);
		WiSizeoftype(type, eclass): WiSizeoftype(lowerTuplesInWiType(type), eclass);
		WiPolycall(e, types, eclass): WiPolycall(rec(e), map(types, lowerTuplesInWiType), eclass);
		WiTupledot(e, int_0, eclass): WiTupledot(rec(e), int_0, eclass); // TODO ?
		WiDefoftype(type, eclass): WiDefoftype(lowerTuplesInWiType(type), eclass);
		WiInt(int_0, eclass): v;
		WiVar(id, eclass): {
			fieldType = resolveWiseAstTypeByEclass(unionFindMap, eclass, \inf, err -> println(err + " [" + toString(inf) + "]"));
			switch (fieldType : WiseAstType) {
				default : v;
				WiseAstTypeTuple(__) : {
					ttype = lowerTuplesInWiType(wiseAstType2wiType(fieldType, eclass, unionFindMap));
					switch (ttype : WiType) {
						WiTupletype(ttypes, eclass2): WiTuple(mapi(ttypes, \j, t -> WiTupledot(v, j, 0)), eclass2);
						default : v;
					}
				}
				
			}
		}
	}
}

unrollWiTuple(v : WiTuple, unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> WiExp {
	unpair(
		unrollWiTupleFields(v.exps, unionFindMap, tmpCntr),
		\beforeExps, tupleFields -> {
			newTuple = WiTuple(tupleFields, 0);
			beforeExps ?? setLastEmptyBrace(beforeExps, newTuple) : newTuple;
		}
	);
}

unrollWiTupleFields(exps : [WiExp], unionFindMap : UnionFindMap<[WiseAstType]>, tmpCntr : ref int) -> Pair<Maybe<WiLet>, [WiExp]> {
	foldi2(exps, None(), [], \i, beforeExps, tupleFields : [WiExp], fe -> {
		fieldType = resolveWiseAstTypeByEclass(unionFindMap, fe.eclass, \inf, err -> println(err + " [" + toString(inf) + "]"));
		switch (fieldType : WiseAstType) {
			default : Pair(beforeExps, arrayPush(tupleFields, fe));
			WiseAstTypeTuple(types) : {
				tmpVar = WiVar("_tmp" + i2s(^(tmpCntr)), 0);
				tmpCntr := (^(tmpCntr)) + 1;
				origTypes = wiseAstType2wiType(fieldType, fe.eclass, unionFindMap);
				ttypes = switch (origTypes : WiType) {
					WiTupletype(t, __): t;
					default : {
						println("ERROR: wrong tuple type. Found " + toString(origTypes));
						[];
					}
				}
				fieldTypes = unrollWiTupletype(ttypes);
				value = lowerTuplesInWiExp(fe, unionFindMap, tmpCntr);
				newLet = WiLet(tmpVar.id, 0, WiTupletype(fieldTypes, 0), value, WiBrace([], 0), 0);
				tmpTuple = Some(eitherMap(beforeExps, \b -> setLastEmptyBrace(b, newLet), newLet));
				varName = tmpVar;//either(getReturnVariable(value), tmpVar);
				newTupleFields = mapi(fieldTypes, \j, t -> WiTupledot(varName, j, 0));
				Pair(tmpTuple, concat(tupleFields, newTupleFields));
			}
		}
	});
}

// ?
/* getReturnVariable(e : WiExp) -> Maybe<WiVar> {
	switch (e : WiExp) {
		WiVar(__, __) : Some(e);
		WiBrace(exps, __) : if (exps != []) getReturnVariable(exps[length(exps) - 1]) else None();
		WiReturn(exps, __) : if (exps != []) getReturnVariable(exps[length(exps) - 1]) else None();
		WiWhile(__, exp2, __) : getReturnVariable(exp2);
		WiAdd(__, __, __): None();
		WiAnd(__, __, __): None();
		WiBool(__, __): None();
		WiBreak(__): None();
		WiContinue(__): None();
		WiDefoftype(__, __): None();
		WiDouble(__, __): None();
		WiHex32(__, __): None();
		WiHex64(__, __): None();
		WiHexf32(__, __): None();
		WiHexf64(__, __): None();
		WiI64(__, __): None();
		WiIf(__, __, __): None();
		WiIfelse(__, __, __, __): None();
		WiInt(__, __): None();
		WiSet(__, __, __): None();
		WiSizeoftype(__, __): None();
		WiTuple(__, __): None();
		WiBoolAnd(__, __, __): None();
		WiBoolNot(__, __): None();
		WiBoolOr(__, __, __): None();
		WiCall(__, __, __): None();
		WiDiv(__, __, __): None();
		WiEqual(__, __, __): None();
		WiGreater(__, __, __): None();
		WiGreaterEqual(__, __, __): None();
		WiGreaterEqualu(__, __, __): None();
		WiGreateru(__, __, __): None();
		WiIsNull(__, __): None();
		WiLess(__, __, __): None();
		WiLessEqual(__, __, __): None();
		WiLessEqualu(__, __, __): None();
		WiLessu(__, __, __): None();
		WiLet(__, __, __, __, __, __): None();
		WiMod(__, __, __): None();
		WiMul(__, __, __): None();
		WiNegate(__, __): None();
		WiNotEqual(__, __, __): None();
		WiOr(__, __, __): None();
		WiPolycall(__, __, __): None();
		WiSub(__, __, __): None();
		WiTupledot(__, __, __): None();
		WiTypeannotation(__, __, __): None();
		WiWasmOp(__, __, __, __): None();
		WiXor(__, __, __): None();
	}
} */

setLastEmptyBrace(l : WiLet, v : WiExp) -> WiLet {
	if (l.brace.expsemi == []) {
		WiLet(l with brace = WiBrace([v], v.eclass));
	} else {
		lastVal = l.brace.expsemi[length(l.brace.expsemi) - 1];
		switch (lastVal : WiExp) {
			WiLet(__, __, __, __, __, __) : {
				newVal = setLastEmptyBrace(lastVal, v);
				WiLet(l with brace = WiBrace(arrayPush(subrange(l.brace.expsemi, 0, length(l.brace.expsemi) - 1), newVal), newVal.eclass))
			}
			default : l;
		}
		
	}
}