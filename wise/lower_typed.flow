import wise/wise_types;
import wase/wase_types;
import wise/type_ast;
import wise/wiseast_dot;
import ds/arrayutils;

export {
	lowerWiseAst2WaseAst(w : WiseAst, typeEnv : TypeWiseAstState, dots : ref Set<WaseDotFn>) -> WaseAst;
}

LowerWiseAstEnv(
	blocks : int,
	loops : [int],
	locals : Tree<string, WiType>,
	fns : Tree<string, WiType>, // returnType
	dots : ref Set<WaseDotFn>,
	typeEnv : TypeWiseAstState,
	tmpCntr : ref int,
	onError : (WiseAst, string) -> void, 
);

makeLowerWiseAstEnv() -> LowerWiseAstEnv {
	LowerWiseAstEnv(0, [], makeTree(), makeTree(), ref makeSet(), makeTypeWiseAstState(nop2), ref 0, nop2);
}

lowerWiseAst2WaseAst(w : WiseAst, typeEnv : TypeWiseAstState, dots : ref Set<WaseDotFn>) -> WaseAst {
	env = LowerWiseAstEnv(makeLowerWiseAstEnv() with
		fns = extractFnNamesFromWiseAst(w, makeTree()),
		typeEnv = typeEnv,
		dots = dots,
		onError = \ast, error -> println(error + " at: " + toString(ast))
	);
	lowerWiseAstToWaseAst(env, w);
}

lowerWiseAstToWaseAst(env : LowerWiseAstEnv, w : WiseAst) -> WaseAst {
	rec = \w1 -> lowerWiseAstToWaseAst(env, w1);

	switch (w) {
		WiseAstList(value): WaseAstList(mapList(value, rec));
		WiseAstBool(value): WaseAstBool(value);
		WiseAstInt(value): WaseAstInt(value);
		WiseAstDouble(value): WaseAstDouble(value);
		WiseAstString(value): WaseAstString(value);
		WiExp(): WiExp2WeExp(env, w);
		WiDecl(): WiDecl2WeDecl(env, w);
		WiType(): WiType2WeType(w);
		WiIdtype(__, __, __): WiIdtype2WeIdtype(w);
	}
}

WiIdtype2WeIdtype(w : WiIdtype) -> WeIdtype {
	WeIdtype(w.id, WiType2WeType(w.type));
}

WiDecl2WeDecl(env : LowerWiseAstEnv, w : WiDecl) -> WeDecl {
	lowerExp = \exp -> WiExp2WeExp(env, exp);
	lowerDecl = \decl -> WiDecl2WeDecl(env, decl);
	switch (w : WiDecl) {
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl, __): {
			// TODO: tuple -> vars
			args = lambdaargs;//unrollWiTupleArg(lambdaargs);
			newEnv = LowerWiseAstEnv(env with locals = fold(lambdaargs, env.locals, \acc, t -> setTree(acc, t.id, t.type)));
			WeFunction(id, optexport, map(args, WiIdtype2WeIdtype), WiType2WeTypes(type), WiExp2WeExp(newEnv, expr), lowerDecl(decl));
		}
		WiGlobal(id, optexport, type, optmutable, expr, decl, __): {
			WeGlobal(id, optexport, WiType2WeType(type), optmutable, lowerExp(expr), lowerDecl(decl));
		}
		WiImport(id1, type, optmutable, id2, id3, decl, __): {
			makeGlobalImport = \-> WeImportGlobal(id1, WiType2WeType(type), optmutable, id2, id3, lowerDecl(decl));
			switch(type : WiType) {
				WiFntype(types, type0, __): WeImportFun(id1, WeFnType(map(types, WiType2WeType), WiType2WeTypes(type0)), id2, id3, lowerDecl(decl));
				WiBasictype(__, __) : makeGlobalImport();
				WiTupletype(__, __) : makeGlobalImport();
			}
		}
		WiWiseInclude(s, decl, __): WeWaseInclude(s, lowerDecl(decl));
		WiWaseEmpty(__): WeWaseEmpty();
	}
}

WiWarg2WeWarg(w : WiWarg) -> WeWarg {
	switch (w : WiWarg) {
		WiInt(int_0, __): WeInt(int_0);
		WiVar(id, __): WeString(id);
		WiType(): WiType2WeType(w);
	}
} 

WiExp2WeExp(env : LowerWiseAstEnv, w : WiExp) -> WeExp {
	rec = \w1 -> WiExp2WeExp(env, w1);
	// TODO : (1>0 && 4>0) -> bool!=i32 (greater - bool, boolean - i32)
	switch (w : WiExp) {
		WiAdd(exp1, exp2, __): WeAdd(rec(exp1), rec(exp2));
		WiAnd(exp1, exp2, __): WeAnd(rec(exp1), rec(exp2));
		WiBool(b, __): WeInt(if (b) 1 else 0);
		WiBreak(__): {
			depth = (env.blocks - 1) - (if (env.loops == []) {
				env.onError(w, "break only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("break", [WeInt(depth)], []); // exps?
		}
		WiContinue(__): {
			depth = (env.blocks - 2) - (if (env.loops == []) {
				env.onError(w, "continue only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("continue", [WeInt(depth)], []); // exps?
		}
		WiDouble(double_0, __): WeDouble(double_0);
		WiHex32(s, __): WeHex32(s);
		WiHex64(s, __): WeHex64(s);
		WiHexf32(s, __): WeHexf32(s);
		WiHexf64(s, __): WeHexf64(s);
		WiI64(s, __): WeI64(s);
		WiIf(exp1, exp2, __): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			WeIf(cond, then);
		}
		WiIfelse(exp1, exp2, exp3, __): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			elsec = WiExp2WeExp(nenv, exp3);
			WeIfelse(cond, then, elsec);
		}
		WiInt(int_0, __): WeInt(int_0);
		WiReturn(exps, __): WeReturn(WeBrace(map(exps, rec)));
		WiSet(id, e, __): WeSet(id, rec(e));
		WiTuple(exps, __): WeTuple(map(exps, rec));
		WiVar(id, __): {
			if (containsKeyTree(env.fns, id) && !containsKeyTree(env.locals, id)) {
				WeWasmOp("fn", [WeString(id)], [])
			} else {
				WeVar(id)
			}
		}
		WiWhile(exp1, exp2, __): {
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 2, loops = arrayPush(env.loops, env.blocks));
			// while (cond) { <exp> } =>
			// block { loop { break_if<2>(!cond); <exp>; break<>() } }
			// cond, exp, type = void
			cond = WiExp2WeExp(nenv, exp1);
			body = WiExp2WeExp(nenv, exp2);
			WeBlock([
				WeLoop([
					WeWasmOp(
						"break_if", 
						[WeInt(1)], 
						[WeBoolNegate(cond)]), 
					body, 
					WeWasmOp("break", [], [])
				])
			])
		}
		WiBoolAnd(exp1, exp2, __): WeIfelse(rec(exp1), rec(exp2), makeWeFalse()); // TODO: If a does not have side-effects, we can do a bitwise and
		WiBoolNot(e, __): WeIfelse(rec(e), makeWeFalse(), makeWeTrue());
		WiBoolOr(exp1, exp2, __): WeIfelse(rec(exp1), makeWeTrue(), rec(exp2)); // TODO: If a does not have side-effects, we can do a bitwise or
		WiBrace(expsemi, __): WeBrace(map(expsemi, rec));
		WiCall(e, exps, __): {
			indirect = \fncall -> {
				fnargs = map(exps, rec);
				// swap fnargs and fnname (due to DSL ?)
				WeWasmOp("call_indirect", [], arrayPush(fnargs, fncall))
			};
			fnId = getWiVarId(e);
			if (fnId == "") {
				indirect(rec(e));
			} else {
				if (containsKeyTree(env.locals, fnId)) {
					indirect(WeVar(fnId))
				} else {
					WeCall(WeVar(fnId), map(exps, rec))
				}
			}
		}
		WiDiv(exp1, exp2, __): WeDiv(rec(exp1), rec(exp2));
		WiEqual(exp1, exp2, __): WeEqual(rec(exp1), rec(exp2));
		WiGreater(exp1, exp2, __): WeGreater(rec(exp1), rec(exp2));
		WiGreaterEqual(exp1, exp2, __): WeGreaterEqual(rec(exp1), rec(exp2));
		WiGreaterEqualu(exp1, exp2, __): WeWasmOp("ge_u", [], [rec(exp1), rec(exp2)]);
		WiGreateru(exp1, exp2, __): WeWasmOp("gt_u", [], [rec(exp1), rec(exp2)]);
		WiIsNull(e, __): WeIsNull(rec(e));
		WiLess(exp1, exp2, __): WeLess(rec(exp1), rec(exp2));
		WiLessEqual(exp1, exp2, __): WeLessEqual(rec(exp1), rec(exp2));
		WiLessEqualu(exp1, exp2, __): WeWasmOp("le_u", [], [rec(exp1), rec(exp2)]);
		WiLessu(exp1, exp2, __): WeWasmOp("lt_u", [], [rec(exp1), rec(exp2)]);
		WiLet(id, i, opttype, e, brace, __): wiLet2weLet(env, w);
		WiMod(exp1, exp2, __): WeMod(rec(exp1), rec(exp2));
		WiMul(exp1, exp2, __): WeMul(rec(exp1), rec(exp2));
		WiNegate(e, __): WeNegate(rec(e));
		WiNotEqual(exp1, exp2, __): WeNotEqual(rec(exp1), rec(exp2));
		WiOr(exp1, exp2, __): WeOr(rec(exp1), rec(exp2));
		WiSub(exp1, exp2, __): WeSub(rec(exp1), rec(exp2));
		WiTypeannotation(e, type, __): WeTypeAnnotation(rec(e), WiType2WeTypes(type));
		WiWasmOp(s, wargs, exps, __): WeWasmOp(s, map(wargs, WiWarg2WeWarg), map(exps, rec));
		WiXor(exp1, exp2, __): WeXor(rec(exp1), rec(exp2));
		WiSizeoftype(type, __): WeInt(0);
		WiPolycall(e, types, __): rec(e);
		WiTupledot(e, int_0, __): tupledot2WeAst(env, w);
		WiDefoftype(type, __): WeInt(0);
	}
}

getWiVarId(e : WiseAst) -> string {
	switch (e : WiseAst) {
		WiVar(id, __):  id;
		default: "";
	}
}

makeWeFalse() -> WeExp {
	WeInt(0); // WeEqual(WeInt(0), WeInt(1));
}
makeWeTrue() -> WeExp {
	WeInt(1); // WeEqual(WeInt(1), WeInt(1));
}

WeBoolNegate(b : WeExp) -> WeExp {
	onError = \ -> {
		// println("can't negate the non-bool value : " + toString(b));
		WeIfelse(b, makeWeFalse(), makeWeTrue());
	}
	switch (b : WeExp) {
		WeNotEqual(e1, e2) : WeEqual(e1, e2);
		WeEqual(e1, e2) : WeNotEqual(e1, e2);
		WeGreater(e1, e2) : WeLessEqual(e1, e2);
		WeGreaterEqual(e1, e2) : WeLess(e1, e2);
		WeLess(e1, e2) : WeGreaterEqual(e1, e2);
		WeLessEqual(e1, e2) : WeGreater(e1, e2);
		WeAnd(__, __) : onError();
		WeOr(__, __) : onError();
		WeXor(__,__) : onError();
		WeAdd(__, __) : onError();
		WeSub(__, __) : onError();
		WeMul(__, __) : onError();
		WeDiv(__, __) : onError();
		WeMod(__, __) : onError();
		WeNegate(__) : onError();
		WeTypeAnnotation(__, __) : onError();
		WeWasmOp(__, __, __) : onError();
		WeAtom() : onError();
		WeBrace(__) : onError();
		WeCall(__, __) : onError();
		WeCall2(__, __) : onError();
		WeLet(__, __, __, __, __) : onError();
		WeLettuple(__, __, __, __, __) : onError();
		WeIsNull(__) : onError();
	}
}

WiType2WeType(w : WiType) -> WeType {
	rec = \w1 -> WiType2WeType(w1);
	switch (w : WiType) {
		WiBasictype(s, __): WeType(s);
		WiFntype(types, type, __): WeType("i32");
		WiTupletype(types, __): if (types == []) WeType("") else rec(types[0]); // TODO
	}
}

WiType2WeTypes(w : WiType) -> [WeType] {
	unrollAndMapWiType(w, \t -> WeType(t.s));
}

unrollAndMapWiType(w : WiType, fn : (WiBasictype) -> ?) -> [?] {
	switch (w : WiType) {
		WiBasictype(s, __): [fn(w)];
		WiFntype(types, type, __): concat(fold(types, [], \acc, t -> concat(acc, unrollAndMapWiType(t, fn))), unrollAndMapWiType(type, fn));
		WiTupletype(types, __): fold(types, [], \acc, t -> concat(acc, unrollAndMapWiType(t, fn)));
	}
}

wiLet2weLet(env : LowerWiseAstEnv, w : WiLet) -> WeExp {
	newEnv = LowerWiseAstEnv(env with locals = setTree(env.locals, w.id, w.opttype));
	recE = \w1 -> WiExp2WeExp(newEnv, w1);
	rec = \w1 -> WiExp2WeExp(env, w1);
	makeLetVar = \-> WeLet(w.id, w.i, WiType2WeType(w.opttype), rec(w.exp), WeBrace(map(w.brace.expsemi, recE)));
	switch (w.opttype : WiType) {
		WiBasictype(__, __): makeLetVar();
		WiFntype(__, __, __): makeLetVar();
		WiTupletype(__, __): wiLet2weLettuple(env, w, w.opttype);
	}
}

wiLet2weLettuple(env : LowerWiseAstEnv, w : WiLet, ttype : WiTupletype) -> WeLettuple {
	newEnv = LowerWiseAstEnv(env with locals = setTree(env.locals, w.id, w.opttype));
	recE = \w1 -> WiExp2WeExp(newEnv, w1);
	recTuple = \e, ttypes -> {
		switch (e : WiExp) {
			WiTuple(exps, __): {
				unpair(getTupleConstructFields(env, e, ttypes, [], []), \constrTmp : [WeExp], fields : [WeExp] -> {
					WeBrace(arrayPush(constrTmp, WeTuple(fields)))
				})
			}
			default : WiExp2WeExp(env, e); // ok. we have the 'flat' type here
		}
	}
	WeLettuple(
		w.id,
		w.i,
		WiType2WeTypes(w.opttype),
		recTuple(w.exp, ttype.types),
		WeBrace(map(w.brace.expsemi, recE))
	);
}

getTupleConstructFields(env : LowerWiseAstEnv, e : WiTuple, fieldTypes : [WiType], tmpConstr : [WeExp], fields : [WeExp]) -> Pair<[WeExp], [WeExp]> {
	if (length(e.exps) != length(fieldTypes)) {
		env.onError(e, "ERROR: the number of tuple types and expressions do not match");
		Pair([], []);
	} else {
		res = mapi(e.exps, \i, fe -> {
			fieldType = fieldTypes[i];
			switch (fieldType : WiType) {
				WiBasictype(__, __) : Pair(None(), [WiExp2WeExp(env, fe)]);
				WiFntype(__, __, __) : Pair(None(), [WiExp2WeExp(env, fe)]);
				WiTupletype(tTypes, eclass) : {
					tmpVar = WiVar("_tmp" + i2s(^(env.tmpCntr)), eclass);
					env.tmpCntr := (^(env.tmpCntr)) + 1;
					newEnv = LowerWiseAstEnv(env with
								locals = setTree(env.locals, tmpVar.id, fieldType),
								// another type ? flat
								typeEnv = TypeWiseAstState(env.typeEnv with vars = setTree(env.typeEnv.vars, tmpVar.id, resolveWiseAstTypeByEclass(env.typeEnv.unionFindMap, eclass, env.onError)))
					);
					typeWiseAst(newEnv.typeEnv, tmpVar);
					tmpTuple = wiLet2weLettuple(newEnv, WiLet(
						tmpVar.id,
						0,
						fieldType,
						fe,
						WiBrace([], 0),
						eclass
					), fieldType);
					newTuple = mapi(unrollAndMapWiType(fieldType, idfn), \j, t -> {
						wtd = WiTupledot(tmpVar, j, 0/* fe.eclass */);
						wtd2 = extractWiExpFromWiseAst(typeWiseAst(newEnv.typeEnv, wtd)); // неверный тип. должно быть число, а у нас tuple!
						WiExp2WeExp(newEnv, wtd2)
					});
					Pair(Some(tmpTuple), newTuple);
				}
			}
		});
		fold(res, Pair([], []), \acc, p -> Pair(maybeArrayPush(acc.first, p.first), concat(acc.second, p.second)));
	}
}

foldWiTypeTuple(t : WiType, ind : [int], fn : ([int], WiType) -> ?) -> [?] {
	switch (t : WiType) {
		WiBasictype(__, __) : [fn(ind, t)];
		WiFntype(__, __, __) : [fn(ind, t)];
		WiTupletype(fields, __) : concatA(mapi(fields, \i, at -> foldWiTypeTuple(at, arrayPush(ind, i), fn)));
	}
}

extractFnNamesFromWiseAst(w : WiseAst, acc : Tree<string, WiType>,) -> Tree<string, WiType> {
	switch (w) {
		WiseAstList(value): foldList(value, acc, \acc2, v -> extractFnNamesFromWiseAst(v, acc2));
		WiseAstBool(__): acc;
		WiseAstInt(__): acc;
		WiseAstDouble(__): acc;
		WiseAstString(__): acc;
		WiExp(): acc;
		WiType(): acc;
		WiIdtype(__, __, __): acc;
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl, __): extractFnNamesFromWiseAst(decl, setTree(acc, id, type));
		WiGlobal(id, optexport, type, optmutable, expr, decl, __): extractFnNamesFromWiseAst(decl, acc);
		WiImport(id1, type, optmutable, id2, id3, decl, __): extractFnNamesFromWiseAst(decl, acc);
		WiWaseEmpty(__): acc;
		WiWiseInclude(s, decl, __): extractFnNamesFromWiseAst(decl, acc);
	}
}

wiFieldPath2index(route : [int], types : WiseAstType, acc : int) -> int {
	if (route == []) {
		acc;
	} else {
		pathLength = ref -1;
		foundItem = findItemInWiTypes(types, [], \itemPath, __ -> {
			pathLength := ^pathLength + 1;
			itemPath == route;
		});
		if (foundItem) ^pathLength else -1;
	}
}

// todo: tail recursion
findItemInWiTypes(v : WiseAstType, route : [int], fn : ([int], WiseAstType) -> bool) -> bool {
	switch (v : WiseAstType) {
		WiseAstTypeI32() : fn(route, v);
		WiseAstTypeI64() : fn(route, v);
		WiseAstTypeF32() : fn(route, v);
		WiseAstTypeF64() : fn(route, v);
		WiseAstTypeFunc(__, __) : fn(route, v);
		WiseAstTypeSIMD() : fn(route, v);
		WiseAstTypeBool() : fn(route, v);
		WiseAstTypeString() : fn(route, v);
		WiseAstTypeEclass(__) : fn(route, v);
		WiseAstTypeTuple(types) : foldi(types, false, \i, acc, item ->
			acc || findItemInWiTypes(item, arrayPush(route, i), fn)
		);
	}
}

tupledot2WeAst(env : LowerWiseAstEnv, d : WiTupledot) -> WeExp {
	makeDotFnAndPushToEnv = \value, index, types -> {
		dotVal = extractWiExpFromWiseAst(typeWiseAst(env.typeEnv, extractNotTupleDot(value)));
		dot = makeWeTupleDotFn(dotVal, index, types, env.tmpCntr, env.typeEnv.unionFindMap);
		env.dots := insertSet(^(env.dots), dot.fn);
		WiExp2WeExp(env, dot.value);
	}
	untriple(makeTupledotData(env, d, []), \varNameM, types, path -> {
		index = wiFieldPath2index(path, types, -1);
		eitherFn(
			varNameM,
			\varName -> {
				if (index > -1) {
					WeVar(varName + "." + i2s(index));
				} else {
					env.onError(d, "ERROR: wrong index of tuple " + toString(path));
					WiExp2WeExp(env, d.exp);
				}
			},
			\-> {
				if (index < 0) {
					env.onError(d, "ERROR: wrong index of tuple " + toString(path) + " " + toString(types));
					WiExp2WeExp(env, d.exp);
				} else {
					makeDotFnAndPushToEnv(d.exp, index, types);
				}
			}
		);
	});
}

extractWiExpFromWiseAst(e : WiseAst) -> WiExp {
	switch (e : WiseAst) {
		WiExp() : e;
		default : {
			println("can't extract expression from WiseAst: " + toString(e));
			WiBrace([], 0);
		}
	}
}

extractNotTupleDot(e : WiExp) -> WiExp {
	switch (e : WiExp) {
		WiTupledot(e2, __, __): extractNotTupleDot(e2);
		default : e;
	}
}

// TODO: construct?, fnResult
makeTupledotData(env : LowerWiseAstEnv, e : WiExp, indexes : [int]) -> Triple<Maybe<string>, WiseAstType, [int]> {
	rec = \e2 -> resolveWiseAst(env.typeEnv.unionFindMap, e2, env.onError);
	defType = WiseAstTypeEclass(-1);
	switch (e : WiExp) {
		WiTupledot(e1, ind, __): makeTupledotData(env, e1, concat([ind], indexes));
		WiTuple(exps, eclass) : Triple(None(), rec(e), indexes);
		WiVar(id, __) : Triple(Some(id), eitherMap(lookupTree(env.locals, id), rec, defType), indexes); // eclass
		WiCall(e1, __, __) : Triple(None(), eitherMap(lookupTree(env.fns, getWiVarId(e1)), rec, defType), indexes); // eclass
		default : {
			env.onError(e, "		TODO: types for tupledot from " + toString(e));
			Triple(None(), defType, indexes) // eclass
		};
	}
}
