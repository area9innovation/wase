import wise/wise_types;
import wase/wase_types;
import wise/type_ast;
import wise/wiseast_dot;

export {
	lowerWiseAst2WaseAst(w : WiseAst) -> WaseAst;
}

LowerWiseAstEnv(
	blocks : int,
	loops : [int],
	locals : Set<string>,
	fns : Set<string>,
	dots : ref Set<WaseDotFn>,
	onError : (WiseAst, string) -> void, 
);

makeLowerWiseAstEnv() -> LowerWiseAstEnv {
	LowerWiseAstEnv(0, [], makeSet(), makeSet(), ref makeSet(), nop2);
}

lowerWiseAst2WaseAst(w : WiseAst) -> WaseAst {
	env = LowerWiseAstEnv(makeLowerWiseAstEnv() with
		fns = extractFnNamesFromWiseAst(w, makeSet()),
		onError = \ast, error -> println(error + " at: " + toString(ast))
	);
	lowerWiseAstToWaseAst(env, w);
}

lowerWiseAstToWaseAst(env : LowerWiseAstEnv, w : WiseAst) -> WaseAst {
	rec = \w1 -> lowerWiseAstToWaseAst(env, w1);

	switch (w) {
		WiseAstList(value): WaseAstList(mapList(value, rec));
		WiseAstBool(value): WaseAstBool(value);
		WiseAstInt(value): WaseAstInt(value);
		WiseAstDouble(value): WaseAstDouble(value);
		WiseAstString(value): WaseAstString(value);
		WiExp(): WiExp2WeExp(env, w);
		WiDecl(): WiDecl2WeDecl(env, w);
		WiType(): WiType2WeType(w);
		WiIdtype(__, __): WiIdtype2WeIdtype(w);
	}
}

WiIdtype2WeIdtype(w : WiIdtype) -> WeIdtype {
	WeIdtype(w.id, WiType2WeType(w.type));
}

WiDecl2WeDecl(env : LowerWiseAstEnv, w : WiDecl) -> WeDecl {
	lowerExp = \exp -> WiExp2WeExp(env, exp);
	lowerDecl = \decl -> WiDecl2WeDecl(env, decl);
	switch (w : WiDecl) {
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl): {
			newEnv = LowerWiseAstEnv(env with locals = fold(lambdaargs, env.locals, \acc, t -> insertSet(acc, t.id)));
			WeFunction(id, optexport, map(lambdaargs, WiIdtype2WeIdtype), WiType2WeTypes(type), WiExp2WeExp(newEnv, expr), lowerDecl(decl));
		}
		WiGlobal(id, optexport, type, optmutable, expr, decl): {
			WeGlobal(id, optexport, WiType2WeType(type), optmutable, lowerExp(expr), lowerDecl(decl));
		}
		WiImport(id1, type, optmutable, id2, id3, decl): {
			makeGlobalImport = \-> WeImportGlobal(id1, WiType2WeType(type), optmutable, id2, id3, lowerDecl(decl));
			switch(type : WiType) {
				WiFntype(types, type0): WeImportFun(id1, WeFnType(map(types, WiType2WeType), WiType2WeTypes(type0)), id2, id3, lowerDecl(decl));
				WiBasictype(__) : makeGlobalImport();
				WiTupletype(__) : makeGlobalImport();
			}
		}
		WiWiseInclude(s, decl): WeWaseInclude(s, lowerDecl(decl));
		WiWaseEmpty(): WeWaseEmpty();
	}
}

WiWarg2WeWarg(w : WiWarg) -> WeWarg {
	switch (w : WiWarg) {
		WiInt(int_0): WeInt(int_0);
		WiVar(id): WeString(id);
		WiType(): WiType2WeType(w);
	}
} 

WiExp2WeExp(env : LowerWiseAstEnv, w : WiExp) -> WeExp {
	rec = \w1 -> WiExp2WeExp(env, w1);
	// TODO : (1>0 && 4>0) -> bool!=i32 (greater - bool, boolean - i32)
	switch (w : WiExp) {
		WiAdd(exp1, exp2): WeAdd(rec(exp1), rec(exp2));
		WiAnd(exp1, exp2): WeAnd(rec(exp1), rec(exp2));
		WiBool(b): WeInt(if (b) 1 else 0);
		WiBreak(): {
			depth = (env.blocks - 1) - (if (env.loops == []) {
				env.onError(w, "break only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("break", [WeInt(depth)], []); // exps?
		}
		WiContinue(): {
			depth = (env.blocks - 2) - (if (env.loops == []) {
				env.onError(w, "continue only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("continue", [WeInt(depth)], []); // exps?
		}
		WiDouble(double_0): WeDouble(double_0);
		WiHex32(s): WeHex32(s);
		WiHex64(s): WeHex64(s);
		WiHexf32(s): WeHexf32(s);
		WiHexf64(s): WeHexf64(s);
		WiI64(s): WeI64(s);
		WiIf(exp1, exp2): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			WeIf(cond, then);
		}
		WiIfelse(exp1, exp2, exp3): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			elsec = WiExp2WeExp(nenv, exp3);
			WeIfelse(cond, then, elsec);
		}
		WiInt(int_0): WeInt(int_0)
		WiReturn(exps): WeReturn(rec(exps[0]))
		WiSet(id, e): WeSet(id, rec(e))
		WiTuple(exps): WeTuple(map(exps, rec))
		WiVar(id): {
			if (containsSet(env.fns, id) && !containsSet(env.locals, id)) {
				WeWasmOp("fn", [WeString(id)], [])
			} else {
				WeVar(id)
			}
		}
		WiWhile(exp1, exp2): {
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 2, loops = arrayPush(env.loops, env.blocks));
			// while (cond) { <exp> } =>
			// block { loop { break_if<2>(!cond); <exp>; break<>() } }
			// cond, exp, type = void
			cond = WiExp2WeExp(nenv, exp1);
			body = WiExp2WeExp(nenv, exp2);
			WeBlock([
				WeLoop([
					WeWasmOp(
						"break_if", 
						[WeInt(1)], 
						[WeBoolNegate(cond)]), 
					body, 
					WeWasmOp("break", [], [])
				])
			])
		}
		WiBoolAnd(exp1, exp2): WeIfelse(rec(exp1), rec(exp2), makeWeFalse()); // TODO: If a does not have side-effects, we can do a bitwise and
		WiBoolNot(e): WeIfelse(rec(e), makeWeFalse(), makeWeTrue());
		WiBoolOr(exp1, exp2): WeIfelse(rec(exp1), makeWeTrue(), rec(exp2)); // TODO: If a does not have side-effects, we can do a bitwise or
		WiBrace(expsemi): WeBrace(map(expsemi, rec));
		WiCall(e, exps): {
			indirect = \fncall -> {
				fnargs = map(exps, rec);
				WeWasmOp("call_indirect", [], concat([fncall], fnargs))
			};

			switch (e : WiseAst) {
				WiVar(id):  {
					fnId = WeVar(id);
					if (containsSet(env.locals, id)) {
						indirect(fnId)
					} else {
						WeCall(fnId, map(exps, rec))
					}
				}
				default: indirect(rec(e))
			}
		}
		WiDiv(exp1, exp2): WeDiv(rec(exp1), rec(exp2));
		WiEqual(exp1, exp2): WeEqual(rec(exp1), rec(exp2));
		WiGreater(exp1, exp2): WeGreater(rec(exp1), rec(exp2));
		WiGreaterEqual(exp1, exp2): WeGreaterEqual(rec(exp1), rec(exp2));
		WiGreaterEqualu(exp1, exp2): WeWasmOp("ge_u", [], [rec(exp1), rec(exp2)]);
		WiGreateru(exp1, exp2): WeWasmOp("gt_u", [], [rec(exp1), rec(exp2)]);
		WiIsNull(e): WeIsNull(rec(e));
		WiLess(exp1, exp2): WeLess(rec(exp1), rec(exp2));
		WiLessEqual(exp1, exp2): WeLessEqual(rec(exp1), rec(exp2));
		WiLessEqualu(exp1, exp2): WeWasmOp("le_u", [], [rec(exp1), rec(exp2)]);
		WiLessu(exp1, exp2): WeWasmOp("lt_u", [], [rec(exp1), rec(exp2)]);
		WiLet(id, i, opttype, e, brace): {
			newEnv = LowerWiseAstEnv(env with locals = insertSet(env.locals, id));
			recE = \w1 -> WiExp2WeExp(newEnv, w1);
			WeLet(id, i, WiType2WeType(opttype), rec(e), WeBrace(map(brace.expsemi, recE)));
		}
		WiMod(exp1, exp2): WeMod(rec(exp1), rec(exp2));
		WiMul(exp1, exp2): WeMul(rec(exp1), rec(exp2));
		WiNegate(e): WeNegate(rec(e));
		WiNotEqual(exp1, exp2): WeNotEqual(rec(exp1), rec(exp2));
		WiOr(exp1, exp2): WeOr(rec(exp1), rec(exp2));
		WiSub(exp1, exp2): WeSub(rec(exp1), rec(exp2));
		WiTypeannotation(e, type): WeTypeAnnotation(rec(e), WiType2WeTypes(type));
		WiWasmOp(s, wargs, exps): WeWasmOp(s, map(wargs, WiWarg2WeWarg), map(exps, rec));
		WiXor(exp1, exp2): WeXor(rec(exp1), rec(exp2));
		WiSizeoftype(type): WeInt(0);
		WiPolycall(e, types): rec(e);
		WiTupledot(e, int_0): tupledot2WeAst(env, w);
		WiDefoftype(type): WeInt(0);
	}
}

makeWeFalse() -> WeExp {
	WeInt(0); // WeEqual(WeInt(0), WeInt(1));
}
makeWeTrue() -> WeExp {
	WeInt(1); // WeEqual(WeInt(1), WeInt(1));
}

WeBoolNegate(b : WeExp) -> WeExp {
	onError = \ -> {
		// println("can't negate the non-bool value : " + toString(b));
		WeIfelse(b, makeWeFalse(), makeWeTrue());
	}
	switch (b : WeExp) {
		WeNotEqual(e1, e2) : WeEqual(e1, e2);
		WeEqual(e1, e2) : WeNotEqual(e1, e2);
		WeGreater(e1, e2) : WeLessEqual(e1, e2);
		WeGreaterEqual(e1, e2) : WeLess(e1, e2);
		WeLess(e1, e2) : WeGreaterEqual(e1, e2);
		WeLessEqual(e1, e2) : WeGreater(e1, e2);
		WeAnd(__, __) : onError();
		WeOr(__, __) : onError();
		WeXor(__,__) : onError();
		WeAdd(__, __) : onError();
		WeSub(__, __) : onError();
		WeMul(__, __) : onError();
		WeDiv(__, __) : onError();
		WeMod(__, __) : onError();
		WeNegate(__) : onError();
		WeTypeAnnotation(__, __) : onError();
		WeWasmOp(__, __, __) : onError();
		WeAtom() : onError();
		WeBrace(__) : onError();
		WeCall(__, __) : onError();
		WeCall2(__, __) : onError();
		WeLet(__, __, __, __, __) : onError();
		WeLettuple(__, __, __, __, __) : onError();
		WeIsNull(__) : onError();
	}
}

WiType2WeType(w : WiType) -> WeType {
	rec = \w1 -> WiType2WeType(w1);
	switch (w : WiType) {
		WiBasictype(s): WeType(s);
		WiFntype(types, type): WeType("i32"); 
		WiTupletype(types): if (types == []) WeType("") else rec(types[0]); // TODO
	}
}

WiType2WeTypes(w : WiType) -> [WeType] {
	switch (w : WiType) {
		WiBasictype(s): [WeType(s)]
		WiFntype(types, type): concat(fold(types, [], \acc, t -> concat(acc, WiType2WeTypes(t))), WiType2WeTypes(type))
		WiTupletype(types): fold(types, [], \acc, t -> concat(acc, WiType2WeTypes(t)))
	}
}

extractFnNamesFromWiseAst(w : WiseAst, acc : Set<string>) -> Set<string> {
	switch (w) {
		WiseAstList(value): foldList(value, acc, \acc2, v -> extractFnNamesFromWiseAst(v, acc2));
		WiseAstBool(__): acc;
		WiseAstInt(__): acc;
		WiseAstDouble(__): acc;
		WiseAstString(__): acc;
		WiExp(): acc;
		WiType(): acc;
		WiIdtype(__, __): acc;
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl): extractFnNamesFromWiseAst(decl, insertSet(acc, id));
		WiGlobal(id, optexport, type, optmutable, expr, decl): extractFnNamesFromWiseAst(decl, acc);
		WiImport(id1, type, optmutable, id2, id3, decl): extractFnNamesFromWiseAst(decl, acc);
		WiWaseEmpty(): acc;
		WiWiseInclude(s, decl): extractFnNamesFromWiseAst(decl, acc);
	}
}

// TupleDot

/* extractVarInfo(arg : DslNode, indexes : [int]) -> Triple<Maybe<string>, DslAst, [int]> {
	if (arg.name == "var") {
		if (length(arg.args) >= 2) {
			Triple(Some(getDslString(arg.args[0])), arg.args[1], indexes);
		} else {
			Triple(None(), arg.args[1], indexes);
		}
	} else if (arg.name == "tupledot") {
		extractVarInfo(getDslNode(arg.args[0]), concat([getDslInt(arg.args[1])], indexes));
	} else if (arg.name == "tuple") {
		Triple(None(), arg.args[1], indexes);
	} else if (arg.name == "call") {
		Triple(None(), arg.args[2], indexes);
	} else {
		Triple(None(), arg, indexes);
	}
}

fieldPath2index(route : [int], types : DslAst, acc : int) -> int {
	if (route == []) {
		acc;
	} else {
		pathLength = ref -1;
		foundItem = findItemInDslAst(types, [], \itemPath, item -> {
			pathLength := ^pathLength + 1;
			itemPath == route;
		});
		if (foundItem) ^pathLength else -1;
	}
}

// todo: tail recursion
findItemInDslAst(v : DslAst, route : [int], fn : ([int], DslAst) -> bool) -> bool {
	switch (v : DslAst) {
		DslBool(__) : fn(route, v);
		DslInt(__) : fn(route, v);
		DslDouble(__) : fn(route, v);
		DslString(__) : fn(route, v);
		DslList(l) : foldiList(l, false, \i, acc, item ->
			acc || findItemInDslAst(item, arrayPush(route, i), fn)
		);
		DslNode(__, __, __) : fn(route, v);
	}
} */

tupledot2WeAst(env : LowerWiseAstEnv, d : WiTupledot) -> WeExp {
	WeBrace([])
	/* arg = getDslNode(d.args[0]);
	
	onErrorTupledot = \val -> {
		env.onError(d, ". only for tuples " + prettyDsl(val));
		d;
	}
	makeDotFnAndPushToEnv = \value, index, types  -> {
		dot = makeDotFn(value, index, types, d.pos);
		env.dots := insertSet(^(env.dots), dot.fn);
		dot.value;
	}
	makeNestedDotFn = \index, dotIndex, primTypes -> makeDotFnAndPushToEnv(
		lowerWise2Wase(env, extractTupldotValue(d.args[0])),
		if (index >= 0) DslInt(index) else dotIndex,
		getDslTupleTypes(primTypes)
	);
	// tuple construction
	makeTupleConstructExp = \index, primTypes -> {
		loweredValue = lowerWise2Wase(env, d.args[0]);
		dotIndex = lowerWise2Wase(env, d.args[1]);
		varType = wiseType(loweredValue);
		switch (varType) {
			DslList(t): {
				types = getDslTupleTypes(varType);
				if (exists(types, \v -> !isPrimitiveDslType(v))) {
					makeNestedDotFn(index, dotIndex, primTypes); // nested dot for construction
				} else {
					makeDotFnAndPushToEnv(loweredValue, dotIndex, orderDotFnTypes(arg, types));
				}
			}
			DslNode(name, __, __) : if (name == "call") {
				makeNestedDotFn(index, dotIndex, primTypes);
			} else {
				onErrorTupledot(varType);
			}
			default: onErrorTupledot(varType);
		}
	}
	if (arg.name == "var" || arg.name == "tupledot") {
		untriple(
			if (arg.name == "var") extractVarInfo(d, []) else extractVarInfo(arg, [getDslInt(d.args[1])]),
			\varNameM, types, path -> {
				index = fieldPath2index(path, types, -1);
				eitherFn(
					varNameM,
					\varName -> {
						// do not fall below. stop tree traversal
						// varName.field1.field2;
						if (index > -1) {
							DslNode("var", [DslString(varName + "." + i2s(index))], d.pos);
						} else {
							env.onError(d, "wrong index of tuple " + prettyDsl(d));
							d;
						}
					},
					\-> makeTupleConstructExp(index, types)
				)
			}
		);
	} else {
		makeTupleConstructExp(-1, DslList(makeList()))
	} */
}

/* extractTupldotValue(d : DslAst) -> DslAst {
	switch (d) {
		DslNode(name, args, __): if (name == "tupledot") extractTupldotValue(args[0]) else d;
		default: d;
	}
}

// TODO: think about the order
// example : 
// Tuple(i32, f64);
// makeTuple() -> Tuple;
// Tuple(1, 1.1) == [f64, i32]
// makeTuple() == [i32, f64]
orderDotFnTypes(node : DslNode, types : [DslAst]) -> [DslAst] {
	if (node.name == "tuple") {
		// tuples have reversed types
		reverseA(types)
	} else {
		types;
	}
} */