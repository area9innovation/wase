import wise/wise_types;
import wase/wase_types;
import wise/type_ast;
import wise/wiseast_dot;

export {
	lowerWiseAst2WaseAst(w : WiseAst) -> WaseAst;
}

LowerWiseAstEnv(
	blocks : int,
	loops : [int],
	locals : Tree<string, WiType>,
	fns : Tree<string, WiType>, // returnType
	dots : ref Set<WaseDotFn>,
	onError : (WiseAst, string) -> void, 
);

makeLowerWiseAstEnv() -> LowerWiseAstEnv {
	LowerWiseAstEnv(0, [], makeTree(), makeTree(), ref makeSet(), nop2);
}

lowerWiseAst2WaseAst(w : WiseAst) -> WaseAst {
	env = LowerWiseAstEnv(makeLowerWiseAstEnv() with
		fns = extractFnNamesFromWiseAst(w, makeTree()),
		onError = \ast, error -> println(error + " at: " + toString(ast))
	);
	lowerWiseAstToWaseAst(env, w);
}

lowerWiseAstToWaseAst(env : LowerWiseAstEnv, w : WiseAst) -> WaseAst {
	rec = \w1 -> lowerWiseAstToWaseAst(env, w1);

	switch (w) {
		WiseAstList(value): WaseAstList(mapList(value, rec));
		WiseAstBool(value): WaseAstBool(value);
		WiseAstInt(value): WaseAstInt(value);
		WiseAstDouble(value): WaseAstDouble(value);
		WiseAstString(value): WaseAstString(value);
		WiExp(): WiExp2WeExp(env, w);
		WiDecl(): WiDecl2WeDecl(env, w);
		WiType(): WiType2WeType(w);
		WiIdtype(__, __): WiIdtype2WeIdtype(w);
	}
}

WiIdtype2WeIdtype(w : WiIdtype) -> WeIdtype {
	WeIdtype(w.id, WiType2WeType(w.type));
}

WiDecl2WeDecl(env : LowerWiseAstEnv, w : WiDecl) -> WeDecl {
	lowerExp = \exp -> WiExp2WeExp(env, exp);
	lowerDecl = \decl -> WiDecl2WeDecl(env, decl);
	switch (w : WiDecl) {
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl): {
			newEnv = LowerWiseAstEnv(env with locals = fold(lambdaargs, env.locals, \acc, t -> setTree(acc, t.id, t.type)));
			WeFunction(id, optexport, map(lambdaargs, WiIdtype2WeIdtype), WiType2WeTypes(type), WiExp2WeExp(newEnv, expr), lowerDecl(decl));
		}
		WiGlobal(id, optexport, type, optmutable, expr, decl): {
			WeGlobal(id, optexport, WiType2WeType(type), optmutable, lowerExp(expr), lowerDecl(decl));
		}
		WiImport(id1, type, optmutable, id2, id3, decl): {
			makeGlobalImport = \-> WeImportGlobal(id1, WiType2WeType(type), optmutable, id2, id3, lowerDecl(decl));
			switch(type : WiType) {
				WiFntype(types, type0): WeImportFun(id1, WeFnType(map(types, WiType2WeType), WiType2WeTypes(type0)), id2, id3, lowerDecl(decl));
				WiBasictype(__) : makeGlobalImport();
				WiTupletype(__) : makeGlobalImport();
			}
		}
		WiWiseInclude(s, decl): WeWaseInclude(s, lowerDecl(decl));
		WiWaseEmpty(): WeWaseEmpty();
	}
}

WiWarg2WeWarg(w : WiWarg) -> WeWarg {
	switch (w : WiWarg) {
		WiInt(int_0): WeInt(int_0);
		WiVar(id): WeString(id);
		WiType(): WiType2WeType(w);
	}
} 

WiExp2WeExp(env : LowerWiseAstEnv, w : WiExp) -> WeExp {
	rec = \w1 -> WiExp2WeExp(env, w1);
	// TODO : (1>0 && 4>0) -> bool!=i32 (greater - bool, boolean - i32)
	switch (w : WiExp) {
		WiAdd(exp1, exp2): WeAdd(rec(exp1), rec(exp2));
		WiAnd(exp1, exp2): WeAnd(rec(exp1), rec(exp2));
		WiBool(b): WeInt(if (b) 1 else 0);
		WiBreak(): {
			depth = (env.blocks - 1) - (if (env.loops == []) {
				env.onError(w, "break only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("break", [WeInt(depth)], []); // exps?
		}
		WiContinue(): {
			depth = (env.blocks - 2) - (if (env.loops == []) {
				env.onError(w, "continue only in while");
				0;
			} else lastElement(env.loops, 0));
			WeWasmOp("continue", [WeInt(depth)], []); // exps?
		}
		WiDouble(double_0): WeDouble(double_0);
		WiHex32(s): WeHex32(s);
		WiHex64(s): WeHex64(s);
		WiHexf32(s): WeHexf32(s);
		WiHexf64(s): WeHexf64(s);
		WiI64(s): WeI64(s);
		WiIf(exp1, exp2): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			WeIf(cond, then);
		}
		WiIfelse(exp1, exp2, exp3): {
			// TODO: What about bool_or and bool_and?
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 1);
			cond = WiExp2WeExp(nenv, exp1);
			then = WiExp2WeExp(nenv, exp2);
			elsec = WiExp2WeExp(nenv, exp3);
			WeIfelse(cond, then, elsec);
		}
		WiInt(int_0): WeInt(int_0)
		WiReturn(exps): WeReturn(rec(exps[0]))
		WiSet(id, e): WeSet(id, rec(e))
		WiTuple(exps): WeTuple(map(exps, rec))
		WiVar(id): {
			if (containsKeyTree(env.fns, id) && !containsKeyTree(env.locals, id)) {
				WeWasmOp("fn", [WeString(id)], [])
			} else {
				WeVar(id)
			}
		}
		WiWhile(exp1, exp2): {
			nenv = LowerWiseAstEnv(env with blocks = env.blocks + 2, loops = arrayPush(env.loops, env.blocks));
			// while (cond) { <exp> } =>
			// block { loop { break_if<2>(!cond); <exp>; break<>() } }
			// cond, exp, type = void
			cond = WiExp2WeExp(nenv, exp1);
			body = WiExp2WeExp(nenv, exp2);
			WeBlock([
				WeLoop([
					WeWasmOp(
						"break_if", 
						[WeInt(1)], 
						[WeBoolNegate(cond)]), 
					body, 
					WeWasmOp("break", [], [])
				])
			])
		}
		WiBoolAnd(exp1, exp2): WeIfelse(rec(exp1), rec(exp2), makeWeFalse()); // TODO: If a does not have side-effects, we can do a bitwise and
		WiBoolNot(e): WeIfelse(rec(e), makeWeFalse(), makeWeTrue());
		WiBoolOr(exp1, exp2): WeIfelse(rec(exp1), makeWeTrue(), rec(exp2)); // TODO: If a does not have side-effects, we can do a bitwise or
		WiBrace(expsemi): WeBrace(map(expsemi, rec));
		WiCall(e, exps): {
			indirect = \fncall -> {
				fnargs = map(exps, rec);
				// swap fnargs and fnname (due to DSL ?)
				WeWasmOp("call_indirect", [], arrayPush(fnargs, fncall))
			};
			fnId = getWiVarId(e);
			if (fnId == "") {
				indirect(rec(e));
			} else {
				if (containsKeyTree(env.locals, fnId)) {
					indirect(WeVar(fnId))
				} else {
					WeCall(WeVar(fnId), map(exps, rec))
				}
			}
		}
		WiDiv(exp1, exp2): WeDiv(rec(exp1), rec(exp2));
		WiEqual(exp1, exp2): WeEqual(rec(exp1), rec(exp2));
		WiGreater(exp1, exp2): WeGreater(rec(exp1), rec(exp2));
		WiGreaterEqual(exp1, exp2): WeGreaterEqual(rec(exp1), rec(exp2));
		WiGreaterEqualu(exp1, exp2): WeWasmOp("ge_u", [], [rec(exp1), rec(exp2)]);
		WiGreateru(exp1, exp2): WeWasmOp("gt_u", [], [rec(exp1), rec(exp2)]);
		WiIsNull(e): WeIsNull(rec(e));
		WiLess(exp1, exp2): WeLess(rec(exp1), rec(exp2));
		WiLessEqual(exp1, exp2): WeLessEqual(rec(exp1), rec(exp2));
		WiLessEqualu(exp1, exp2): WeWasmOp("le_u", [], [rec(exp1), rec(exp2)]);
		WiLessu(exp1, exp2): WeWasmOp("lt_u", [], [rec(exp1), rec(exp2)]);
		WiLet(id, i, opttype, e, brace): wiLet2weLet(env, w);
		WiMod(exp1, exp2): WeMod(rec(exp1), rec(exp2));
		WiMul(exp1, exp2): WeMul(rec(exp1), rec(exp2));
		WiNegate(e): WeNegate(rec(e));
		WiNotEqual(exp1, exp2): WeNotEqual(rec(exp1), rec(exp2));
		WiOr(exp1, exp2): WeOr(rec(exp1), rec(exp2));
		WiSub(exp1, exp2): WeSub(rec(exp1), rec(exp2));
		WiTypeannotation(e, type): WeTypeAnnotation(rec(e), WiType2WeTypes(type));
		WiWasmOp(s, wargs, exps): WeWasmOp(s, map(wargs, WiWarg2WeWarg), map(exps, rec));
		WiXor(exp1, exp2): WeXor(rec(exp1), rec(exp2));
		WiSizeoftype(type): WeInt(0);
		WiPolycall(e, types): rec(e);
		WiTupledot(e, int_0): tupledot2WeAst(env, w);
		WiDefoftype(type): WeInt(0);
	}
}

getWiVarId(e : WiseAst) -> string {
	switch (e : WiseAst) {
		WiVar(id):  id;
		default: "";
	}
}

makeWeFalse() -> WeExp {
	WeInt(0); // WeEqual(WeInt(0), WeInt(1));
}
makeWeTrue() -> WeExp {
	WeInt(1); // WeEqual(WeInt(1), WeInt(1));
}

WeBoolNegate(b : WeExp) -> WeExp {
	onError = \ -> {
		// println("can't negate the non-bool value : " + toString(b));
		WeIfelse(b, makeWeFalse(), makeWeTrue());
	}
	switch (b : WeExp) {
		WeNotEqual(e1, e2) : WeEqual(e1, e2);
		WeEqual(e1, e2) : WeNotEqual(e1, e2);
		WeGreater(e1, e2) : WeLessEqual(e1, e2);
		WeGreaterEqual(e1, e2) : WeLess(e1, e2);
		WeLess(e1, e2) : WeGreaterEqual(e1, e2);
		WeLessEqual(e1, e2) : WeGreater(e1, e2);
		WeAnd(__, __) : onError();
		WeOr(__, __) : onError();
		WeXor(__,__) : onError();
		WeAdd(__, __) : onError();
		WeSub(__, __) : onError();
		WeMul(__, __) : onError();
		WeDiv(__, __) : onError();
		WeMod(__, __) : onError();
		WeNegate(__) : onError();
		WeTypeAnnotation(__, __) : onError();
		WeWasmOp(__, __, __) : onError();
		WeAtom() : onError();
		WeBrace(__) : onError();
		WeCall(__, __) : onError();
		WeCall2(__, __) : onError();
		WeLet(__, __, __, __, __) : onError();
		WeLettuple(__, __, __, __, __) : onError();
		WeIsNull(__) : onError();
	}
}

WiType2WeType(w : WiType) -> WeType {
	rec = \w1 -> WiType2WeType(w1);
	switch (w : WiType) {
		WiBasictype(s): WeType(s);
		WiFntype(types, type): WeType("i32");
		WiTupletype(types): if (types == []) WeType("") else rec(types[0]); // TODO
	}
}

WiType2WeTypes(w : WiType) -> [WeType] {
	switch (w : WiType) {
		WiBasictype(s): [WeType(s)]
		WiFntype(types, type): concat(fold(types, [], \acc, t -> concat(acc, WiType2WeTypes(t))), WiType2WeTypes(type))
		WiTupletype(types): fold(types, [], \acc, t -> concat(acc, WiType2WeTypes(t)))
	}
}

wiLet2weLet(env : LowerWiseAstEnv, w : WiLet) -> WeExp {
	newEnv = LowerWiseAstEnv(env with locals = setTree(env.locals, w.id, w.opttype));
	recE = \w1 -> WiExp2WeExp(newEnv, w1);
	rec = \w1 -> WiExp2WeExp(env, w1);
	makeLetVar = \-> WeLet(w.id, w.i, WiType2WeType(w.opttype), rec(w.exp), WeBrace(map(w.brace.expsemi, recE)));
	recTuple = \e -> {
		values = map(extractTupleExps(env, e, []), rec);
		switch (e : WiExp) {
			WiTuple(__): WeTuple(values);
			default : if (length(values) == 1) values[0] else WeBrace(values);
		}
	}
	switch (w.opttype : WiType) {
		WiBasictype(__): makeLetVar();
		WiFntype(__, __): makeLetVar();
		WiTupletype(__): WeLettuple(w.id, w.i, WiType2WeTypes(w.opttype), recTuple(w.exp), WeBrace(map(w.brace.expsemi, recE)));
	}
}

extractTupleExps(env : LowerWiseAstEnv, e : WiExp, acc : [WiExp]) -> [WiExp] {
	makeDef = \-> arrayPush(acc, e);
	switch (e : WiExp) {
		WiTuple(exps): fold(exps, acc, \acc2, e1 -> extractTupleExps(env, e1, acc2));
		WiVar(id) : eitherFn(
			lookupTree(env.locals, id),
			\type -> switch (type : WiType) {
				WiTupletype(__) : {
					types = WiType2WeTypes(type);
					concat(acc, mapi(reverseA(types), \i, __ -> WiTupledot(e, i)));
				}
				default : makeDef();
			},
			makeDef
		);
		default : makeDef();
	}
}

extractFnNamesFromWiseAst(w : WiseAst, acc : Tree<string, WiType>,) -> Tree<string, WiType> {
	switch (w) {
		WiseAstList(value): foldList(value, acc, \acc2, v -> extractFnNamesFromWiseAst(v, acc2));
		WiseAstBool(__): acc;
		WiseAstInt(__): acc;
		WiseAstDouble(__): acc;
		WiseAstString(__): acc;
		WiExp(): acc;
		WiType(): acc;
		WiIdtype(__, __): acc;
		WiFunction(optexport, id, templates, lambdaargs, type, expr, decl): extractFnNamesFromWiseAst(decl, setTree(acc, id, type));
		WiGlobal(id, optexport, type, optmutable, expr, decl): extractFnNamesFromWiseAst(decl, acc);
		WiImport(id1, type, optmutable, id2, id3, decl): extractFnNamesFromWiseAst(decl, acc);
		WiWaseEmpty(): acc;
		WiWiseInclude(s, decl): extractFnNamesFromWiseAst(decl, acc);
	}
}

wiFieldPath2index(route : [int], types : WiType, acc : int) -> int {
	if (route == []) {
		acc;
	} else {
		pathLength = ref -1;
		foundItem = findItemInWiTypes(types, [], \itemPath, item -> {
			pathLength := ^pathLength + 1;
			itemPath == route;
		});
		if (foundItem) ^pathLength else -1;
	}
}

// todo: tail recursion
findItemInWiTypes(v : WiType, route : [int], fn : ([int], WiType) -> bool) -> bool {
	switch (v : WiType) {
		WiBasictype(__) : fn(route, v);
		WiFntype(__, __) : fn(route, v);
		WiTupletype(types) : foldi(types, false, \i, acc, item ->
			acc || findItemInWiTypes(item, arrayPush(route, i), fn)
		);
	}
}

tupledot2WeAst(env : LowerWiseAstEnv, d : WiTupledot) -> WeExp {
	makeDotFnAndPushToEnv = \value, index, types -> {
		dot = makeWeTupleDotFn(value, index, types);
		env.dots := insertSet(^(env.dots), dot.fn);
		WiExp2WeExp(env, dot.value);
	}
	// tuple construction
	makeTupleConstructExp = \index, primTypes -> {
		println("		TODO makeTupleConstructExp : "+i2s(index)+" "+toString(primTypes));
		makeDotFnAndPushToEnv(d.exp, index, primTypes);
	}
	untriple(makeTupledotData(env, d, []), \varNameM, types, path -> {
		index = wiFieldPath2index(path, types, -1);
		eitherFn(
			varNameM,
			\varName -> {
				// do not fall below. stop tree traversal
				// varName.field1.field2;
				if (index > -1) {
					WeVar(varName + "." + i2s(index));
				} else {
					env.onError(d, "wrong index of tuple " + toString(d));
					WiExp2WeExp(env, d);
				}
			},
			\-> makeTupleConstructExp(index, types)
		)
	});
}

// TODO: construct?, fnResult
makeTupledotData(env : LowerWiseAstEnv, e : WiExp, indexes : [int]) -> Triple<Maybe<string>, WiType, [int]> {
	switch (e : WiExp) {
		WiTupledot(e1, ind): makeTupledotData(env, e1, concat([ind], indexes));
		WiTuple(exps) : {
			// TODO: we need real types here. can we use Templates somehow? or it will be too complicated?
			Triple(None(), WiTupletype(map(exps, \__ -> WiBasictype(""))), indexes);
		}
		WiVar(id) : Triple(Some(id), either(lookupTree(env.locals, id), WiBasictype("")), indexes);
		WiCall(e1, __) : Triple(None(), either(lookupTree(env.fns, getWiVarId(e1)), WiBasictype("")), indexes);
		default : {
			env.onError(e, "		TODO: types for tupledot from " + toString(e));
			Triple(None(), WiBasictype(""), indexes)
		};
	}
}

/* extractTupldotValue(d : DslAst) -> DslAst {
	switch (d) {
		DslNode(name, args, __): if (name == "tupledot") extractTupldotValue(args[0]) else d;
		default: d;
	}
}

// TODO: think about the order
// example : 
// Tuple(i32, f64);
// makeTuple() -> Tuple;
// Tuple(1, 1.1) == [f64, i32]
// makeTuple() == [i32, f64]
orderDotFnTypes(node : DslNode, types : [DslAst]) -> [DslAst] {
	if (node.name == "tuple") {
		// tuples have reversed types
		reverseA(types)
	} else {
		types;
	}
} */