import tools/dsl/dsl_ast;
import ds/array;
import runtime;
import wase/compile;

export {
	LowerWiseEnv(
		blocks : int,
		loops : [int],
		onError : (DslAst, string) -> void, 
	);
	lowerWise2Wase(acc : LowerWiseEnv, d : DslAst) -> DslAst;
}

lowerWise2Wase(env : LowerWiseEnv, d : DslAst) -> DslAst {
	list2 = \l, r -> DslList(Cons(r, Cons(l, makeList())));
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(value): DslList(mapList(value, \v -> lowerWise2Wase(env, v)));
		DslNode(name, args, pos): {
			nenv = if (name == "while") {
				LowerWiseEnv(env.blocks + 2, arrayPush(env.loops, env.blocks), env.onError);
			} else if (name == "if" || name == "ifelse") {
				// TODO: What about bool_or and bool_and?
				LowerWiseEnv(env.blocks + 1, env.loops, env.onError);
			} else env;
			largs = map(args, \a -> lowerWise2Wase(nenv, a));
			if (name == "true") {
				DslNode("int", [DslInt(1), DslString("i32")], pos);
			} else if (name == "false") {
				DslNode("int", [DslInt(0), DslString("i32")], pos);
			} else if (name == "bool_or") {
				// Make this short-circuit
				// if (a) 1 else b
				// TODO: If a does not have side-effects, we can do a bitwise or
				DslNode("ifelse", [largs[0], DslInt(1), largs[1], DslString("i32")], pos);
			} else if (name == "bool_and") {
				// Make this short-circuit
				// if (a) b else 0
				// TODO: If a does not have side-effects, we can do a bitwise and
				DslNode("ifelse", [largs[0], largs[1], DslInt(0), DslString("i32")], pos);
			} else if (name == "while") {
				// while (cond) { <exp> } =>
				// block { loop { break_if<2>(!cond); <exp>; break<>() } }
				// cond, exp, type = void
				l = DslNode("block", [
					DslList(makeList1(
					DslNode("loop", [
						DslList(
							fold([
								DslNode("wasm_op", [DslString("break_if"), DslInt(1), negateWise(largs[0]),DslList(makeList())], pos),
								largs[1],
								DslNode("wasm_op", [DslString("break"), DslList(makeList()), DslList(makeList()), DslList(makeList())], pos),
							], makeList(), \acc, e -> Cons(e, acc))
						), largs[2]
					], pos))), 
					DslList(makeList())
				], pos);
				// println(l);
				l;
			} else if (name == "break") {
				depth = (env.blocks - 1) - (if (env.loops == []) {
					env.onError(d, "break only in while");
					0;
				} else lastElement(env.loops, 0));
				DslNode("wasm_op", [DslString("break"), DslList(makeList1(DslInt(depth))), DslList(makeList()), largs[0]], pos);
			} else if (name == "continue") {
				depth = (env.blocks - 2) - (if (env.loops == []) {
					env.onError(d, "continue only in while");
					0;
				} else lastElement(env.loops, 0));
				DslNode("wasm_op", [DslString("break"), DslList(makeList1(DslInt(depth))), DslList(makeList()), largs[0]], pos);
			} else if (name == "import") {
				if (getDslNode(largs[1]).name == "fntype") {
					DslNode("import_fun", [largs[0], largs[1], largs[3], largs[4], largs[5]], pos)
				} else {
					DslNode("import_global", largs, pos)
				}
			} else if (name == "and" || name == "or" || name == "xor") {
				// OK, check that the type is integer
				type = waseType(d);
				if (type != DslString("i32") && type != DslString("i64")) {
					env.onError(d, "bitwise operation only works on i32 and i64");
				}
				DslNode(name, largs, pos);
			} else if (name == "equal" || name == "not_equal" || name == "less_equal" || name == "less"
				|| name == "greater_equal" || name == "greater") {
				// The type becomes int
				DslNode(name, [largs[0], largs[1], DslString("i32")], pos)
			} else if (name == "less_equalu") {
				DslNode("wasm_op", [DslString("le_u"), DslList(makeList()), list2(largs[0], largs[1]), DslString("i32")], pos)
			} else if (name == "lessu") {
				DslNode("wasm_op", [DslString("lt_u"), DslList(makeList()), list2(largs[0], largs[1]), DslString("i32")], pos)
			} else if (name == "greater_equalu") {
				DslNode("wasm_op", [DslString("ge_u"), DslList(makeList()), list2(largs[0], largs[1]), DslString("i32")], pos)
			} else if (name == "greateru") {
				DslNode("wasm_op", [DslString("gt_u"), DslList(makeList()), list2(largs[0], largs[1]), DslString("i32")], pos)
			} else {
				type = lastElement(args, d);
				if (type == DslString("bool")) {
					println("Figure out how to get rid of bool type when lowering: " + prettyDsl(d));
				}
				DslNode(name, largs, pos);
			}
		}
	}
}

negateWise(d : DslAst) -> DslAst {
	n = getDslNode(d);
	name = n.name;
	flip = \nn -> DslNode(nn, n.args, n.pos);
	if (name == "equal") flip("not_equal")
	else if (name == "not_equal") flip("equal")
	else if (name == "less_equal") flip("greater")
	else if (name == "less") flip("greater_equal")
	else if (name == "greater_equal") flip("less")
	else if (name == "greater") flip("less_equal")
	else if (name == "bool_not") n.args[0]
	else {
		DslNode("bool_not", [d, DslString("bool")], n.pos);
	}
}
