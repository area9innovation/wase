import tools/dsl/dsl_ast;
import ds/array;
import runtime;
import wase/compile;

export {
	lowerWise2Wase(onError : (DslAst, string) -> void, d : DslAst) -> DslAst;
}

lowerWise2Wase(onError : (DslAst, string) -> void, d : DslAst) -> DslAst {
	switch (d) {
		DslBool(value): d;
		DslInt(value): d;
		DslDouble(value): d;
		DslString(value): d;
		DslList(value): DslList(mapList(value, \v -> lowerWise2Wase(onError, v)));
		DslNode(name, args, pos): {
			largs = map(args, \a -> lowerWise2Wase(onError, a));
			if (name == "true") {
				DslNode("int", [DslInt(1), DslString("i32")], pos);
			} else if (name == "false") {
				DslNode("int", [DslInt(0), DslString("i32")], pos);
			} else if (name == "bool_or") {
				// Make this short-circuit
				// if (a) 1 else b
				// TODO: If a does not have side-effects, we can do a bitwise or
				DslNode("ifelse", [largs[0], DslInt(1), largs[1], DslString("i32")], pos);
			} else if (name == "bool_and") {
				// Make this short-circuit
				// if (a) b else 0
				// TODO: If a does not have side-effects, we can do a bitwise and
				DslNode("ifelse", [largs[0], largs[1], DslInt(0), DslString("i32")], pos);
			} else if (name == "while") {
				// while (cond) { <exp> } =>
				// loop { break_if<1>(!cond); <exp>; break<>() }
				// cond, exp, type = void
				// TODO: Record label for break and continue inside
				l = DslNode("loop", [
					DslList(
						fold([
							DslNode("wasm_op", [DslString("break_if"), DslInt(1), 
								negateWise(largs[0]),
							DslList(makeList())], pos),
							largs[1],
							DslNode("wasm_op", [DslString("break"), DslList(makeList()), DslList(makeList()), DslList(makeList())], pos),

						], makeList(), \acc, e -> Cons(e, acc))
					), largs[2]
				], pos);
				// println(prettyDsl(l));
				l;
			} else if (name == "and" || name == "or" || name == "xor") {
				// OK, check that the type is integer
				type = waseType(d);
				if (type != DslString("i32") && type != DslString("i64")) {
					onError(d, "bitwise operation only works on i32 and i64");
				}
				DslNode(name, largs, pos);
			} else if (name == "equal" || name == "not_equal" || name == "less_equal" || name == "less"
				|| name == "greater_equal" || name == "greater") {
				// The type becomes int
				DslNode(name, [largs[0], largs[1], DslString("i32")], pos)
			} else {
				type = lastElement(args, d);
				if (type == DslString("bool")) {
					println(prettyDsl(d));
				}
				DslNode(name, largs, pos);
			}
		}
	}
}

negateWise(d : DslAst) -> DslAst {
	n = getDslNode(d);
	name = n.name;
	flip = \nn -> DslNode(nn, n.args, n.pos);
	if (name == "equal") flip("not_equal")
	else if (name == "not_equal") flip("equal")
	else if (name == "less_equal") flip("greater")
	else if (name == "less") flip("greater_equal")
	else if (name == "greater_equal") flip("less")
	else if (name == "greater") flip("less_equal")
	else if (name == "bool_not") n.args[0]
	else {
		DslNode("bool_not", [d, DslString("bool")], n.pos);
	}
}
