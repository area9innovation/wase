import wise/wiseast_types;
import wise/wise_types;
import wase/wase_types;
import wise/type_ast;
import ds/set;
import ds/arrayutils;
import ds/union_find_map;
import text/blueprint;

export {

	makeWeTupleDotFn(e : WiExp, index : int, type : WiseAstType, tmpCntr : ref int, unionFindMap : UnionFindMap<[WiseAstType]>,) -> WaseTupledotFn;
	WaseTupledotFn(
		value : WiExp,
		fn : WaseDotFn,
	);
	WaseDotFn(
		name : string,  // format : dot_type[_type]_index
		argTypes : [WiseAstType],
		index : int,
	);

	addDotNFunctionsToWase(fns : Set<WaseDotFn>, d : WaseAst) -> WaseAst;

}

makeWeTupleDotFn(e : WiExp, index : int, type : WiseAstType, tmpCntr : ref int, unionFindMap : UnionFindMap<[WiseAstType]>,) -> WaseTupledotFn {
	types = extractTupleTypesFromWiseAstTypes([type]);
	dotFn = "dot_"
			+ superglue(types, wiseAstType2dotname, "_") + "_"
			+ (if (index >= 0) i2s(index) else "");
	WaseTupledotFn(
		makeWeTupleDotCallBody(dotFn, e, type, tmpCntr, unionFindMap),
		WaseDotFn(dotFn, types, index)
	);
}

makeWeTupleDotCallBody(dotFn : string, e : WiExp, tupleType : WiseAstType, tmpCntr : ref int, unionFindMap : UnionFindMap<[WiseAstType]>,) -> WiExp {
	tupleEclass = e.eclass;
	tmpVar = WiVar("_conTuple" + i2s(^tmpCntr), tupleEclass);
	tmpCntr := (^tmpCntr) + 1;
	wiType = wiseAstType2wiType(tupleType, tupleEclass, unionFindMap);
	
	wl = WiLet(
		tmpVar.id,
		0,
		wiType,
		e,
		WiBrace(
			[WiCall(
				WiVar(dotFn, 0),
				foldWiseAstTypeTuple(tupleType, [], \indexes, tt -> fold(indexes, tmpVar, \acc, i -> WiTupledot(acc, i, 0))),
				0
			)],
			0
		),
		tupleEclass
	);

	typeEnv = makeTypeWiseAstState2(unionFindMap, \ast, error -> println(error + " at: " + toString(ast)));
	typedLet = typeWiseAst(typeEnv, wl);
	switch (typedLet : WiseAst) {
		WiLet(__, __, __, __, __, __): typedLet;
		default : wl;
	}
}

foldWiseAstTypeTuple(t : WiseAstType, ind : [int], fn : ([int], WiseAstType) -> ?) -> [?] {
	switch (t : WiseAstType) {
		WiseAstTypeI32() : [fn(ind, t)];
		WiseAstTypeI64() : [fn(ind, t)];
		WiseAstTypeF32() : [fn(ind, t)];
		WiseAstTypeF64() : [fn(ind, t)];
		WiseAstTypeFunc(__, __) : [fn(ind, t)];
		WiseAstTypeSIMD() : [fn(ind, t)];
		WiseAstTypeBool() : [fn(ind, t)];
		WiseAstTypeString() : [fn(ind, t)];
		WiseAstTypeTuple(fields) : concatA(mapi(fields, \i, at -> foldWiseAstTypeTuple(at, arrayPush(ind, i), fn)));
		WiseAstTypeEclass(__) : [fn(ind, t)];
	}
}

wiseAstType2wiType(t : WiseAstType, eclass : int, unionFindMap : UnionFindMap<[WiseAstType]>) -> WiType {
	getTypeWithEclass = \ -> {
		typesWithClasses = getUnionMapValue(unionFindMap, eclass);
		if (typesWithClasses == []) WiseAstTypeEclass(0) else typesWithClasses[0];
	}
	switch (t : WiseAstType) {
		WiseAstTypeI32() : WiBasictype("i32", eclass);
		WiseAstTypeI64() : WiBasictype("i64", eclass);
		WiseAstTypeF32() : WiBasictype("f32", eclass);
		WiseAstTypeF64() : WiBasictype("f64", eclass);
		WiseAstTypeFunc(tt, rt) : {
			typeWithClasses = getTypeWithEclass();
			fieldClasses = switch (typeWithClasses : WiseAstType) {
				WiseAstTypeFunc(tt2, rt2) : {
					if (length(tt) != length(tt2)) {
						println("Error : Can't fix eclasses. Wrong function type. Given : " + toString(t) + ". Found : " + toString(typeWithClasses));
					}
					Pair(mapi(tt, \i, f -> elementAtMap(tt2, i, extractEclassFromWiseAstType, 0)), extractEclassFromWiseAstType(rt2));
				}
				default : {
					println("Error : Can't fix eclasses. not a function type. Given : " + toString(t) + ". Found : " + toString(typeWithClasses));
					Pair(map(tt, \__ -> 0), 0);
				}
			}
			WiFntype(
				mapi(tt, \i, at -> wiseAstType2wiType(at, fieldClasses.first[i], unionFindMap)),
				wiseAstType2wiType(rt, fieldClasses.second, unionFindMap),
				eclass
			);
		}
		WiseAstTypeSIMD() : WiBasictype("v128", eclass);
		WiseAstTypeBool() : WiBasictype("i32", eclass);
		WiseAstTypeString() : WiBasictype("i32", eclass);
		WiseAstTypeTuple(fields) : {
			typeWithClasses = getTypeWithEclass();
			fieldClasses = switch (typeWithClasses : WiseAstType) {
				WiseAstTypeTuple(fields2) : {
					if (length(fields) != length(fields2)) {
						println("Error : Can't fix eclasses. Wrong tuple type. Given : " + toString(t) + ". Found : " + toString(typeWithClasses));
					}
					mapi(fields, \i, f -> elementAtMap(fields2, i, extractEclassFromWiseAstType, 0));
				}
				default : {
					println("Error : Can't fix eclasses. not a tuple type. Given : " + toString(t) + ". Found : " + toString(typeWithClasses));
					map(fields, \__ -> 0);
				}
			}
			WiTupletype(
				mapi(fields, \i, ft -> wiseAstType2wiType(ft, fieldClasses[i], unionFindMap)),
				eclass
			);
		}
		WiseAstTypeEclass(id) : WiBasictype("", id);
	}
}

extractEclassFromWiseAstType(t : WiseAstType) -> int {
	switch (t : WiseAstType) {
		WiseAstTypeI32() : 0;
		WiseAstTypeI64() : 0;
		WiseAstTypeF32() : 0;
		WiseAstTypeF64() : 0;
		WiseAstTypeFunc(__, __) : 0;
		WiseAstTypeSIMD() : 0;
		WiseAstTypeBool() : 0;
		WiseAstTypeString() : 0;
		WiseAstTypeTuple(__) : 0;
		WiseAstTypeEclass(id) : id;
	}
}

// the order is not important
extractTupleTypesFromWiseAstTypes(types : [WiseAstType]) -> [WiseAstType] {
	mapConcat(types, \t -> switch (t : WiseAstType) {
		WiseAstTypeI32() : [t];
		WiseAstTypeI64() : [t];
		WiseAstTypeF32() : [t];
		WiseAstTypeF64() : [t];
		WiseAstTypeFunc(__, __) : [t];
		WiseAstTypeSIMD() : [t];
		WiseAstTypeBool() : [t];
		WiseAstTypeString() : [t];
		WiseAstTypeTuple(fields) : extractTupleTypesFromWiseAstTypes(fields);
		WiseAstTypeEclass(__) : [t];
	});
}

wiseAstType2dotname(type : WiseAstType) -> string {
	switch (type) {
		WiseAstTypeI32() : "i32";
		WiseAstTypeI64() : "i64";
		WiseAstTypeF32() : "f32";
		WiseAstTypeF64() : "f64";
		WiseAstTypeFunc(tt, rt) : "fn_" + superglue(tt, wiseAstType2dotname, "-") + "--" + wiseAstType2dotname(rt);
		WiseAstTypeSIMD() : "v128";
		WiseAstTypeBool() : "b";
		WiseAstTypeString() : "s";
		WiseAstTypeTuple(fields) : "t_" + superglue(fields, wiseAstType2dotname, "-");
		WiseAstTypeEclass(id) : "e" + i2s(id);
	}
}

addDotNFunctionsToWase(fns : Set<WaseDotFn>, d : WaseAst) -> WaseAst {
	dotFns = foldSet(fns, WeWaseEmpty(), \acc : WeDecl, fn -> {
		types = map(fn.argTypes, wiseAstType2weType);
		returnType = elementAt(types, fn.index, WeType(""));
		WeFunction(
			fn.name,
			"", // optexport
			mapi(types, \i, argType -> WeIdtype("v" + i2s(i), argType)),
			[returnType],
			WeReturn(WeVar("v" + i2s(fn.index))),
			acc
		);
	});
	setDotFns = \w : WeDecl -> {
		foldSet(fns, w, \acc : WeDecl, fn -> {
			types = map(fn.argTypes, wiseAstType2weType);
			returnType = elementAt(types, fn.index, WeType(""));
			WeFunction(
				fn.name,
				"", // optexport
				mapi(types, \i, argType -> WeIdtype("v" + i2s(i), argType)),
				[returnType],
				WeReturn(WeVar("v" + i2s(fn.index))),
				acc
			);
		});
	}
	newValue = switch (d : WaseAst) {
		WeDecl() : addFnToWeDecl(d, setDotFns);
		default : d;
	}
	if (newValue == d && !isEmptySet(fns)) println("ERROR: can't add the dot fns. Declaration is not found");
	newValue;
}

addFnToWeDecl(v : WeDecl, setDotFns : (WeDecl) -> WeDecl) -> WeDecl {
	setFns = \decl, updateWeDecl -> {
		if (decl == WeWaseEmpty()) setDotFns(v) else updateWeDecl(addFnToWeDecl(decl, setDotFns));
	}
	switch (v : WeDecl) {
		WeData(__, __, __, __, decl) : setFns(decl, \newDecl -> WeData(v with decl = newDecl));
		WeFunction(__, __, __, __, __, decl) : setFns(decl, \newDecl -> WeFunction(v with decl = newDecl));
		WeGlobal(__, __, __, __, __, decl) : setFns(decl, \newDecl -> WeGlobal(v with decl = newDecl));
		WeImportFun(__, __, __, __, decl) : setFns(decl, \newDecl -> WeImportFun(v with decl = newDecl));
		WeImportGlobal(__, __, __, __, __, decl) : setFns(decl, \newDecl -> WeImportGlobal(v with decl = newDecl));
		WeImportMemory(__, __, __, __, decl) : setFns(decl, \newDecl -> WeImportMemory(v with decl = newDecl));
		WeImportTable(__, __, __, __, __, __, decl) : setFns(decl, \newDecl -> WeImportTable(v with decl = newDecl));
		WeMemory(__, __, __, decl) : setFns(decl, \newDecl -> WeMemory(v with decl = newDecl));
		WeWaseInclude(__, decl) : setFns(decl, \newDecl -> WeWaseInclude(v with decl = newDecl));
		WeWaseEmpty(): setDotFns(v);
	}
}

wiseAstType2weType(type : WiseAstType) -> WeType {
	makeErrCode = \-> {
		println("Wrong type '" + toString(type) + "' in dotFn");
		""
	}
	code = switch (type) {
		WiseAstTypeI32() : "i32";
		WiseAstTypeI64() : "i64";
		WiseAstTypeF32() : "f32";
		WiseAstTypeF64() : "f64";
		WiseAstTypeFunc(tt, rt) : "i32";
		WiseAstTypeSIMD() : "v128";
		WiseAstTypeBool() : "i32";
		WiseAstTypeString() : "i32";
		WiseAstTypeTuple(fields) : makeErrCode();
		WiseAstTypeEclass(id) : makeErrCode();
	}
	WeType(code);
}